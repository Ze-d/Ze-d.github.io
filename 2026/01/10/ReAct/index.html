<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ReAct | Hexo</title><meta name="author" content="Zed"><meta name="copyright" content="Zed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是一份关于 ReAct (Reasoning + Acting) 技术的深度技术白皮书。它涵盖了从核心原理、底层实现到进阶架构的完整知识体系。 1. 核心定义与背景 (Introduction)ReAct 是 Reasoning（推理） 与 Acting（行动） 的合成词。它是一种用于构建大语言模型（LLM）代理（Agent）的范式。  起源: Google Research (Yao et a">
<meta property="og:type" content="article">
<meta property="og:title" content="ReAct">
<meta property="og:url" content="http://example.com/2026/01/10/ReAct/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这是一份关于 ReAct (Reasoning + Acting) 技术的深度技术白皮书。它涵盖了从核心原理、底层实现到进阶架构的完整知识体系。 1. 核心定义与背景 (Introduction)ReAct 是 Reasoning（推理） 与 Acting（行动） 的合成词。它是一种用于构建大语言模型（LLM）代理（Agent）的范式。  起源: Google Research (Yao et a">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/asuka.jpg">
<meta property="article:published_time" content="2026-01-10T14:11:32.000Z">
<meta property="article:modified_time" content="2026-01-11T04:05:16.757Z">
<meta property="article:author" content="Zed">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="langchain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/asuka.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ReAct",
  "url": "http://example.com/2026/01/10/ReAct/",
  "image": "http://example.com/img/asuka.jpg",
  "datePublished": "2026-01-10T14:11:32.000Z",
  "dateModified": "2026-01-11T04:05:16.757Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zed",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2026/01/10/ReAct/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ReAct',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bkground.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bkground.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">ReAct</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ReAct</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-10T14:11:32.000Z" title="Created 2026-01-10 22:11:32">2026-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-11T04:05:16.757Z" title="Updated 2026-01-11 12:05:16">2026-01-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这是一份关于 <strong>ReAct (Reasoning + Acting)</strong> 技术的深度技术白皮书。它涵盖了从核心原理、底层实现到进阶架构的完整知识体系。</p>
<h2 id="1-核心定义与背景-Introduction"><a href="#1-核心定义与背景-Introduction" class="headerlink" title="1. 核心定义与背景 (Introduction)"></a>1. 核心定义与背景 (Introduction)</h2><p><strong>ReAct</strong> 是 <strong>Reasoning（推理）</strong> 与 <strong>Acting（行动）</strong> 的合成词。它是一种用于构建大语言模型（LLM）代理（Agent）的范式。</p>
<ul>
<li><strong>起源:</strong> Google Research (Yao et al., 2022) 提出的论文 <em>“ReAct: Synergizing Reasoning and Acting in Language Models”</em>。</li>
<li><strong>解决的问题:</strong><ul>
<li>单纯的 <strong>推理 (Chain-of-Thought)</strong> 容易产生幻觉，无法获取外部世界的新知。</li>
<li>单纯的 <strong>行动 (Action)</strong> 缺乏规划，容易在复杂任务中迷失方向。</li>
</ul>
</li>
<li><strong>核心理念:</strong> 让 LLM 在执行任务时，交替进行“思考（生成推理轨迹）”和“行动（调用外部工具）”，并将行动的结果（观察）反哺给模型，形成闭环。</li>
</ul>
<hr>
<h2 id="2-技术架构与工作流-Architecture-Workflow"><a href="#2-技术架构与工作流-Architecture-Workflow" class="headerlink" title="2. 技术架构与工作流 (Architecture &amp; Workflow)"></a>2. 技术架构与工作流 (Architecture &amp; Workflow)</h2><p>ReAct 不是模型本身的一个功能，而是一种<strong>应用层的控制流（Control Flow）</strong>。</p>
<h3 id="2-1-核心循环-The-Loop"><a href="#2-1-核心循环-The-Loop" class="headerlink" title="2.1 核心循环 (The Loop)"></a>2.1 核心循环 (The Loop)</h3><p>一个标准的 ReAct Loop 包含三个原子步骤：</p>
<ol>
<li><strong>Thought (思考):</strong> LLM 分析当前的用户需求和历史状态，决定下一步做什么。<ul>
<li><em>Output:</em> 文本描述或结构化数据。</li>
</ul>
</li>
<li><strong>Action (行动):</strong> LLM 生成具体的工具调用指令（函数名+参数）。<ul>
<li><em>Trigger:</em> 系统检测到工具调用意图，拦截流程。</li>
</ul>
</li>
<li><strong>Observation (观察):</strong> 外部系统（Runtime）执行工具，将运行结果（API 返回值、代码输出）捕获回来。<ul>
<li><em>Input:</em> 将结果追加到 Prompt 中，再次喂给 LLM。</li>
</ul>
</li>
</ol>
<h3 id="2-2-状态机表示-State-Machine"><a href="#2-2-状态机表示-State-Machine" class="headerlink" title="2.2 状态机表示 (State Machine)"></a>2.2 状态机表示 (State Machine)</h3><p>从计算机科学角度看，ReAct 是一个状态机：</p>
<p>$$S_{t+1} &#x3D; LLM(S_t, O_t)$$</p>
<p>其中：</p>
<ul>
<li>$S_t$: 当前的对话历史（包含之前的 Thoughts 和 Actions）。</li>
<li>$O_t$: 上一步 Action 的执行结果（Observation）。</li>
<li>$LLM$: 状态转移函数（大模型）。</li>
</ul>
<hr>
<h2 id="3-实现技术的演进-Evolution"><a href="#3-实现技术的演进-Evolution" class="headerlink" title="3. 实现技术的演进 (Evolution)"></a>3. 实现技术的演进 (Evolution)</h2><p>ReAct 的实现方式经历了两个主要阶段：</p>
<h3 id="阶段一：Prompt-Engineering-基于文本解析"><a href="#阶段一：Prompt-Engineering-基于文本解析" class="headerlink" title="阶段一：Prompt Engineering (基于文本解析)"></a>阶段一：Prompt Engineering (基于文本解析)</h3><ul>
<li><p><strong>机制:</strong> 在 System Prompt 中强行规定格式。</p>
<blockquote>
<p>“如果你要使用工具，请按以下格式输出：Action: [工具名], Action Input: [参数]”</p>
</blockquote>
</li>
<li><p><strong>触发:</strong> 框架（如 LangChain）使用 <strong>正则表达式 (Regex)</strong> 扫描 LLM 的输出。</p>
</li>
<li><p><strong>缺点:</strong> 脆弱，模型容易输出无效格式，参数解析困难（例如 JSON 引号嵌套问题）。</p>
</li>
</ul>
<h3 id="阶段二：Native-Tool-Calling-基于微调与语法约束"><a href="#阶段二：Native-Tool-Calling-基于微调与语法约束" class="headerlink" title="阶段二：Native Tool Calling (基于微调与语法约束)"></a>阶段二：Native Tool Calling (基于微调与语法约束)</h3><ul>
<li><strong>机制:</strong> 现代 LLM (GPT-4, Claude 3, Qwen) 经过专门的 Function Calling 微调。</li>
<li><strong>协议:</strong><ul>
<li>开发者通过 <code>bind_tools</code> 传入 JSON Schema。</li>
<li>模型输出专门的 <code>tool_calls</code> 结构化字段（非纯文本）。</li>
</ul>
</li>
<li><strong>触发:</strong> 框架直接检查 <code>response.tool_calls</code> 对象。</li>
<li><strong>优点:</strong> 鲁棒性极高，支持强类型的参数验证，支持并行调用多个工具。</li>
</ul>
<hr>
<h2 id="4-关键技术组件-Key-Components"><a href="#4-关键技术组件-Key-Components" class="headerlink" title="4. 关键技术组件 (Key Components)"></a>4. 关键技术组件 (Key Components)</h2><p>构建一个生产级的 ReAct Agent 需要以下组件协同工作：</p>
<h3 id="A-路由器-The-Brain"><a href="#A-路由器-The-Brain" class="headerlink" title="A. 路由器 (The Brain)"></a>A. 路由器 (The Brain)</h3><ul>
<li>负责决策。它判断是直接回答用户（Final Answer），还是发起工具调用。</li>
<li><strong>技术点:</strong> 上下文窗口管理（Context Window Management），防止历史记录撑爆 Token 限制。</li>
</ul>
<h3 id="B-工具执行器-The-Hands"><a href="#B-工具执行器-The-Hands" class="headerlink" title="B. 工具执行器 (The Hands)"></a>B. 工具执行器 (The Hands)</h3><ul>
<li>负责将 LLM 的指令（JSON）转换为实际的代码执行。</li>
<li><strong>技术点:</strong> 异常处理（Error Handling）。如果工具报错，需要将错误信息作为 Observation 反馈给 LLM，而不是让程序崩溃。</li>
</ul>
<h3 id="C-记忆存储-The-Memory"><a href="#C-记忆存储-The-Memory" class="headerlink" title="C. 记忆存储 (The Memory)"></a>C. 记忆存储 (The Memory)</h3><ul>
<li><strong>Short-term Memory:</strong> 即 Scratchpad（草稿本），存储当前的 Thought-Action-Observation 链条。</li>
<li><strong>Long-term Memory:</strong> 向量数据库（Vector Store），用于检索跨会话的历史经验。</li>
</ul>
<hr>
<h2 id="5-进阶模式与优化-Advanced-Patterns"><a href="#5-进阶模式与优化-Advanced-Patterns" class="headerlink" title="5. 进阶模式与优化 (Advanced Patterns)"></a>5. 进阶模式与优化 (Advanced Patterns)</h2><p>为了解决 ReAct “死循环”、“迷路”或“低效”的问题，衍生出了以下增强技术：</p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
<th><strong>解决痛点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Plan-and-Solve</strong></td>
<td>先生成完整的 To-Do List，再逐个执行。</td>
<td>解决 ReAct 容易陷入局部细节、缺乏大局观的问题。</td>
</tr>
<tr>
<td><strong>Reflexion</strong></td>
<td>在 Action 报错或结果不理想时，强制 LLM 进行自我反思（Self-Critique）。</td>
<td>提高 Agent 的鲁棒性，具备“知错能改”的能力。</td>
</tr>
<tr>
<td><strong>Human-in-the-loop</strong></td>
<td>在关键 Action 之前挂起（Suspend），等待人工批准。</td>
<td>解决高风险操作（如退款、删库）的安全合规问题。</td>
</tr>
<tr>
<td><strong>Multi-Agent (LangGraph)</strong></td>
<td>将复杂任务拆解，由多个垂直领域的 ReAct Loop 协作完成。</td>
<td>解决单体 Agent 能力边界有限、上下文过长的问题。</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-常见挑战与解决方案-Challenges"><a href="#6-常见挑战与解决方案-Challenges" class="headerlink" title="6. 常见挑战与解决方案 (Challenges)"></a>6. 常见挑战与解决方案 (Challenges)</h2><h3 id="6-1-延迟-Latency"><a href="#6-1-延迟-Latency" class="headerlink" title="6.1 延迟 (Latency)"></a>6.1 延迟 (Latency)</h3><ul>
<li><strong>问题:</strong> ReAct 需要多次串行调用 LLM，响应速度慢。</li>
<li><strong>对策:</strong><ul>
<li>使用速度更快的模型（如 GPT-4o-mini, Groq LPU）。</li>
<li><strong>并行工具调用:</strong> 如果模型同时请求查天气和查股票，并行执行。</li>
</ul>
</li>
</ul>
<h3 id="6-2-循环陷阱-Infinite-Loops"><a href="#6-2-循环陷阱-Infinite-Loops" class="headerlink" title="6.2 循环陷阱 (Infinite Loops)"></a>6.2 循环陷阱 (Infinite Loops)</h3><ul>
<li><strong>问题:</strong> 模型反复尝试同一个失败的操作。</li>
<li><strong>对策:</strong><ul>
<li>设置 <code>max_iterations</code>（最大循环次数）。</li>
<li>在 System Prompt 中加入指令：“如果连续失败 3 次，请向用户寻求帮助”。</li>
</ul>
</li>
</ul>
<h3 id="6-3-成本-Cost"><a href="#6-3-成本-Cost" class="headerlink" title="6.3 成本 (Cost)"></a>6.3 成本 (Cost)</h3><ul>
<li><strong>问题:</strong> 历史记录不断累积，Token 消耗呈指数级增长。</li>
<li><strong>对策:</strong><ul>
<li><strong>Context Trimming:</strong> 仅保留最近 N 轮对话。</li>
<li><strong>Summarization:</strong> 每一轮循环结束后，将之前的长思考过程总结为一句话。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-代码实现参考-LangGraph-伪代码"><a href="#7-代码实现参考-LangGraph-伪代码" class="headerlink" title="7. 代码实现参考 (LangGraph 伪代码)"></a>7. 代码实现参考 (LangGraph 伪代码)</h2><p>在最新的 LangChain 生态（LangGraph）中，ReAct 显式地由“图”定义：</p>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from langgraph.graph import StateGraph, END</span><br><span class="line"></span><br><span class="line"># 1. 定义状态</span><br><span class="line">class AgentState(TypedDict):</span><br><span class="line">    messages: list</span><br><span class="line"></span><br><span class="line"># 2. 定义节点</span><br><span class="line">def call_model(state):</span><br><span class="line">    # 推理逻辑</span><br><span class="line">    response = model.invoke(state[&#x27;messages&#x27;])</span><br><span class="line">    return &#123;&quot;messages&quot;: [response]&#125;</span><br><span class="line"></span><br><span class="line">def execute_tools(state):</span><br><span class="line">    # 行动逻辑</span><br><span class="line">    last_message = state[&#x27;messages&#x27;][-1]</span><br><span class="line">    tool_result = run_tool(last_message.tool_calls)</span><br><span class="line">    return &#123;&quot;messages&quot;: [tool_result]&#125;</span><br><span class="line"></span><br><span class="line"># 3. 定义边 (路由逻辑)</span><br><span class="line">def should_continue(state):</span><br><span class="line">    last_message = state[&#x27;messages&#x27;][-1]</span><br><span class="line">    if last_message.tool_calls:</span><br><span class="line">        return &quot;tools&quot;  # 继续循环</span><br><span class="line">    return END          # 结束，输出给用户</span><br><span class="line"></span><br><span class="line"># 4. 构建图</span><br><span class="line">workflow = StateGraph(AgentState)</span><br><span class="line">workflow.add_node(&quot;agent&quot;, call_model)</span><br><span class="line">workflow.add_node(&quot;tools&quot;, execute_tools)</span><br><span class="line"></span><br><span class="line">workflow.set_entry_point(&quot;agent&quot;)</span><br><span class="line">workflow.add_conditional_edges(&quot;agent&quot;, should_continue, &#123;&quot;tools&quot;: &quot;tools&quot;, END: END&#125;)</span><br><span class="line">workflow.add_edge(&quot;tools&quot;, &quot;agent&quot;) # 工具执行完，必须回到 Agent 再思考</span><br><span class="line"></span><br><span class="line">app = workflow.compile()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>ReAct 是大模型从“聊天机器人”进化为“智能助手”的分水岭技术。它通过 <strong>“推理-行动-观察”</strong> 的迭代循环，赋予了静态模型操作动态世界的能力。</p>
<p>对于开发者而言，理解 ReAct 不仅仅是会用 LangChain 的 API，更重要的是理解其背后的<strong>状态管理、上下文控制以及错误恢复机制</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Zed</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2026/01/10/ReAct/">http://example.com/2026/01/10/ReAct/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/langchain/">langchain</a></div><div class="post-share"><div class="social-share" data-image="/img/asuka.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/09/System-Human-and-AI-message/" title="System Human and AI message"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">System Human and AI message</div></div><div class="info-2"><div class="info-item-1">1. 概述在 LangChain 的 Chat Model 架构中，消息对象（Message Objects）是与大语言模型（LLM）交互的原子单位。它们对底层 API（如 OpenAI Chat Completion API）的角色（Roles）进行了标准化封装，确保了不同模型提供商之间的接口一致性。 2. 组件定义2.1 SystemMessage (系统消息) 定义: 用于设定对话环境、模型行为、角色和边界条件的初始指令。 对应 LLM 角色: system 生命周期: 通常位于消息列表的索引 0 位置，且贯穿整个对话会话。 技术用途: 角色注入 (Persona Injection): 定义模型是谁（如“资深法律顾问”）。 格式约束 (Output Guardrails): 强制规定输出格式（如“仅输出 JSON”）。 安全围栏 (Safety Guidelines): 设定拒绝回答的话题范围。    2.2 HumanMessage (人类消息) 定义: 代表来自外部用户（或客户端应用）的输入内容。 对应 LLM 角色: user 生命周期:...</div></div></div></a><a class="pagination-related" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">langchain标准化prompt</div></div><div class="info-2"><div class="info-item-1">1. 问题背景 (Problem Statement)在传统软件工程中，标准化依赖于精确的语法（Syntax）和强类型系统。而在基于 LangChain 的 LLM 应用开发中，核心逻辑依赖于自然语言（Prompts 和 Tool Descriptions）。 面临的挑战：  不确定性： 自然语言具有歧义性，导致系统行为难以像传统代码那样 100% 预测。 非标化： 不同的开发者编写 Prompt 的质量参差不齐，导致系统稳定性波动。  核心论点： LangChain 无法消除对 Prompt 的依赖（这是 LLM 的物理特性），但它提供了一套工程化框架，将模糊的自然语言逻辑包裹在标准化的软件架构中。  2. 范式转移：自然语言作为新汇编 (The Paradigm Shift)在 AI 工程中，我们需要重新映射编程概念：    传统编程概念 AI 工程对应物 本质变化    函数签名 (Signature) 工具描述 (Description) 从“类型匹配”变为“语义理解”。   业务逻辑 (Logic) Prompt Template 从“流程控制...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/30/LoRA-and-QLoRA/" title="LoRA and QLoRA"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-30</div><div class="info-item-2">LoRA and QLoRA</div></div><div class="info-2"><div class="info-item-1">1. 概述 (Executive Summary)随着大语言模型 (LLM) 参数量的爆炸式增长（7B 至 70B+），传统的全量微调 (Full Fine-Tuning) 因其高昂的算力成本（显存与计算资源）和存储成本，在实际应用中变得难以落地。 LoRA (Low-Rank Adaptation) 与 QLoRA (Quantized LoRA) 是目前最主流的参数高效微调 (PEFT, Parameter-Efficient Fine-Tuning) 技术。它们通过冻结预训练模型权重，仅训练少量新增参数，在大幅降低显存需求的同时，实现了与全量微调相当的性能。 本主要技术指标：  LoRA：显存占用降低约 3 倍，模型文件缩小 1000+ 倍。 QLoRA：在 LoRA 基础上引入 4-bit 量化，进一步降低显存需求（7B 模型仅需 6-8GB 显存即可微调）。   2. LoRA (Low-Rank Adaptation) 技术详解2.1 核心数学原理LoRA 基于一个核心假设：过参数化的大模型在适应特定任务时，其权重更新矩阵具有极低的“内在秩” (Intrinsic...</div></div></div></a><a class="pagination-related" href="/2025/11/24/RAG%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" title="RAG框架及其应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-24</div><div class="info-item-2">RAG框架及其应用</div></div><div class="info-2"><div class="info-item-1">RAG 技术总结1. RAG 是什么？RAG（Retrieval-Augmented Generation，检索增强生成）是一种将信息检索系统与**大语言模型（LLM）**结合的AI架构。模型在回答问题前，先从外部知识库检索相关内容，并将检索结果作为上下文供模型生成答案。 主要解决的问题：  训练数据过时导致知识陈旧 无法访问领域专有&#x2F;内部知识 减少大模型“幻觉”（胡编乱造）   2. RAG 的典型框架🧱 离线阶段（构建知识库） 数据接入 → 企业文档、API 数据库、代码、会议记录等   内容清洗与切分（Chunking）   Embedding 向量化   索引构建（向量数据库：Qdrant &#x2F; Milvus &#x2F; Pinecone 等）  🔍 在线阶段（实时问答） Query 预处理 &#x2F; 重写   检索（向量检索 &#x2F; Hybrid 检索 + Reranker）   构造增强上下文（文档片段 + Prompt）   LLM 生成答案   后处理（格式整理 &#x2F;...</div></div></div></a><a class="pagination-related" href="/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/" title="langchain中Agent的三种调用方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">langchain中Agent的三种调用方式</div></div><div class="info-2"><div class="info-item-1">这份技术文档专门针对 LangChain Agent (智能体) 场景，深度解析三种核心调用方式。 相比于简单的线性链（Chain），Agent 包含复杂的循环、工具调用和自我修正逻辑，因此其调用模式（Execution Patterns）具有独特的行为特征。 1. 概述 (Overview)在 LangChain 1.0 架构中，Agent 本质上是一个实现了 Runnable 协议的复杂状态机。尽管其内部包含 ReAct 循环、工具路由和错误重试机制，但对外依然暴露统一的标准接口：  invoke (同步): 任务交付型。最常用，封装了复杂的中间过程。 stream (流式): 体验增强型。用于实时获取最终回答的 Token，或监控中间步骤。 batch (批量): 效率优化型。用于并发处理多个独立的 Agent 任务。   2. 同步调用：agent.invoke()这是开发 Agent 时最默认、最推荐的调用方式。 2.1 核心逻辑Agent 的工作往往是“结果导向”的。调用 invoke 意味着你启动了一个黑盒进程。  输入:...</div></div></div></a><a class="pagination-related" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">langchain标准化prompt</div></div><div class="info-2"><div class="info-item-1">1. 问题背景 (Problem Statement)在传统软件工程中，标准化依赖于精确的语法（Syntax）和强类型系统。而在基于 LangChain 的 LLM 应用开发中，核心逻辑依赖于自然语言（Prompts 和 Tool Descriptions）。 面临的挑战：  不确定性： 自然语言具有歧义性，导致系统行为难以像传统代码那样 100% 预测。 非标化： 不同的开发者编写 Prompt 的质量参差不齐，导致系统稳定性波动。  核心论点： LangChain 无法消除对 Prompt 的依赖（这是 LLM 的物理特性），但它提供了一套工程化框架，将模糊的自然语言逻辑包裹在标准化的软件架构中。  2. 范式转移：自然语言作为新汇编 (The Paradigm Shift)在 AI 工程中，我们需要重新映射编程概念：    传统编程概念 AI 工程对应物 本质变化    函数签名 (Signature) 工具描述 (Description) 从“类型匹配”变为“语义理解”。   业务逻辑 (Logic) Prompt Template 从“流程控制...</div></div></div></a><a class="pagination-related" href="/2026/01/11/langSmith%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="langSmith功能与工作流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">langSmith功能与工作流</div></div><div class="info-2"><div class="info-item-1">这份文档为您总结了 LangSmith 的核心技术能力及其在 LLM 应用开发全生命周期中的工作流。 1. 核心定位LangSmith 是一个用于构建生产级 LLM 应用程序的 DevOps 平台。它弥补了传统软件开发工具在面对非确定性 LLM 时的不足，提供从原型开发、调试、评估到生产监控的全链路支持。  2. 核心功能详解 (Core Capabilities)2.1 全链路追踪与调试 (Tracing &amp; Debugging)解决 LLM 应用的“黑盒”问题，提供极其细颗粒度的可视性。  功能描述： 自动记录每一次 LLM 调用、Chain 执行、Agent 思考过程及 Tool 使用。 关键特性： 可视化调用树 (Run Tree)： 以层级结构展示调用链，清晰查看输入、输出、Prompt 渲染结果。 瀑布流视图 (Waterfall)：  可视化每个步骤的延迟，快速定位是检索慢还是生成慢。 元数据捕获： 自动记录 Token 消耗、模型参数、延迟和错误堆栈。 Playground 集成： 在 Trace 界面直接修改 Prompt 参数并“重放”...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zed</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ze-d"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">welcome to my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%83%8C%E6%99%AF-Introduction"><span class="toc-number">1.</span> <span class="toc-text">1. 核心定义与背景 (Introduction)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81-Architecture-Workflow"><span class="toc-number">2.</span> <span class="toc-text">2. 技术架构与工作流 (Architecture &amp; Workflow)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E5%BE%AA%E7%8E%AF-The-Loop"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 核心循环 (The Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A1%A8%E7%A4%BA-State-Machine"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 状态机表示 (State Machine)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E8%BF%9B-Evolution"><span class="toc-number">3.</span> <span class="toc-text">3. 实现技术的演进 (Evolution)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9APrompt-Engineering-%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">阶段一：Prompt Engineering (基于文本解析)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9ANative-Tool-Calling-%E5%9F%BA%E4%BA%8E%E5%BE%AE%E8%B0%83%E4%B8%8E%E8%AF%AD%E6%B3%95%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.</span> <span class="toc-text">阶段二：Native Tool Calling (基于微调与语法约束)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6-Key-Components"><span class="toc-number">4.</span> <span class="toc-text">4. 关键技术组件 (Key Components)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E8%B7%AF%E7%94%B1%E5%99%A8-The-Brain"><span class="toc-number">4.1.</span> <span class="toc-text">A. 路由器 (The Brain)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%B7%A5%E5%85%B7%E6%89%A7%E8%A1%8C%E5%99%A8-The-Hands"><span class="toc-number">4.2.</span> <span class="toc-text">B. 工具执行器 (The Hands)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AE%B0%E5%BF%86%E5%AD%98%E5%82%A8-The-Memory"><span class="toc-number">4.3.</span> <span class="toc-text">C. 记忆存储 (The Memory)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E9%98%B6%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96-Advanced-Patterns"><span class="toc-number">5.</span> <span class="toc-text">5. 进阶模式与优化 (Advanced Patterns)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B8%B8%E8%A7%81%E6%8C%91%E6%88%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Challenges"><span class="toc-number">6.</span> <span class="toc-text">6. 常见挑战与解决方案 (Challenges)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%BB%B6%E8%BF%9F-Latency"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 延迟 (Latency)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%BE%AA%E7%8E%AF%E9%99%B7%E9%98%B1-Infinite-Loops"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 循环陷阱 (Infinite Loops)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%88%90%E6%9C%AC-Cost"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 成本 (Cost)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8F%82%E8%80%83-LangGraph-%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">7. 代码实现参考 (LangGraph 伪代码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">8. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langSmith%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="langSmith功能与工作流">langSmith功能与工作流</a><time datetime="2026-01-11T10:02:41.000Z" title="Created 2026-01-11 18:02:41">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/Python-%E6%A8%A1%E5%9D%97%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97-PEP-257/" title="Python 模块文档字符串规范指南 (PEP 257)">Python 模块文档字符串规范指南 (PEP 257)</a><time datetime="2026-01-11T09:22:35.000Z" title="Created 2026-01-11 17:22:35">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/" title="langchain中Agent的三种调用方式">langchain中Agent的三种调用方式</a><time datetime="2026-01-11T07:11:37.000Z" title="Created 2026-01-11 15:11:37">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt">langchain标准化prompt</a><time datetime="2026-01-11T04:32:42.000Z" title="Created 2026-01-11 12:32:42">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/10/ReAct/" title="ReAct">ReAct</a><time datetime="2026-01-10T14:11:32.000Z" title="Created 2026-01-10 22:11:32">2026-01-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bkground.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By Zed</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>