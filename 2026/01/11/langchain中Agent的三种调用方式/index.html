<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>langchain中Agent的三种调用方式 | Hexo</title><meta name="author" content="Zed"><meta name="copyright" content="Zed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这份技术文档专门针对 LangChain Agent (智能体) 场景，深度解析三种核心调用方式。 相比于简单的线性链（Chain），Agent 包含复杂的循环、工具调用和自我修正逻辑，因此其调用模式（Execution Patterns）具有独特的行为特征。 1. 概述 (Overview)在 LangChain 1.0 架构中，Agent 本质上是一个实现了 Runnable 协议的复杂状态机">
<meta property="og:type" content="article">
<meta property="og:title" content="langchain中Agent的三种调用方式">
<meta property="og:url" content="http://example.com/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这份技术文档专门针对 LangChain Agent (智能体) 场景，深度解析三种核心调用方式。 相比于简单的线性链（Chain），Agent 包含复杂的循环、工具调用和自我修正逻辑，因此其调用模式（Execution Patterns）具有独特的行为特征。 1. 概述 (Overview)在 LangChain 1.0 架构中，Agent 本质上是一个实现了 Runnable 协议的复杂状态机">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/asuka.jpg">
<meta property="article:published_time" content="2026-01-11T07:11:37.000Z">
<meta property="article:modified_time" content="2026-01-11T07:12:08.914Z">
<meta property="article:author" content="Zed">
<meta property="article:tag" content="langchain">
<meta property="article:tag" content="llm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/asuka.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "langchain中Agent的三种调用方式",
  "url": "http://example.com/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/",
  "image": "http://example.com/img/asuka.jpg",
  "datePublished": "2026-01-11T07:11:37.000Z",
  "dateModified": "2026-01-11T07:12:08.914Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zed",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'langchain中Agent的三种调用方式',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bkground.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bkground.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">langchain中Agent的三种调用方式</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">langchain中Agent的三种调用方式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-11T07:11:37.000Z" title="Created 2026-01-11 15:11:37">2026-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-11T07:12:08.914Z" title="Updated 2026-01-11 15:12:08">2026-01-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>这份技术文档专门针对 <strong>LangChain Agent (智能体)</strong> 场景，深度解析三种核心调用方式。</p>
<p>相比于简单的线性链（Chain），Agent 包含复杂的循环、工具调用和自我修正逻辑，因此其调用模式（Execution Patterns）具有独特的行为特征。</p>
<h2 id="1-概述-Overview"><a href="#1-概述-Overview" class="headerlink" title="1. 概述 (Overview)"></a>1. 概述 (Overview)</h2><p>在 LangChain 1.0 架构中，Agent 本质上是一个实现了 <code>Runnable</code> 协议的复杂状态机。尽管其内部包含 ReAct 循环、工具路由和错误重试机制，但对外依然暴露统一的标准接口：</p>
<ul>
<li><strong><code>invoke</code> (同步):</strong> 任务交付型。最常用，封装了复杂的中间过程。</li>
<li><strong><code>stream</code> (流式):</strong> 体验增强型。用于实时获取最终回答的 Token，或监控中间步骤。</li>
<li><strong><code>batch</code> (批量):</strong> 效率优化型。用于并发处理多个独立的 Agent 任务。</li>
</ul>
<hr>
<h2 id="2-同步调用：agent-invoke"><a href="#2-同步调用：agent-invoke" class="headerlink" title="2. 同步调用：agent.invoke()"></a>2. 同步调用：<code>agent.invoke()</code></h2><p>这是开发 Agent 时<strong>最默认、最推荐</strong>的调用方式。</p>
<h3 id="2-1-核心逻辑"><a href="#2-1-核心逻辑" class="headerlink" title="2.1 核心逻辑"></a>2.1 核心逻辑</h3><p>Agent 的工作往往是“结果导向”的。调用 <code>invoke</code> 意味着你启动了一个<strong>黑盒进程</strong>。</p>
<ol>
<li><strong>输入:</strong> 用户目标（如“帮我总结这周的销售数据并发邮件”）。</li>
<li><strong>黑盒运行:</strong> Agent 内部进行 N 次 <code>While</code> 循环（思考 $\rightarrow$ 调 Excel 工具 $\rightarrow$ 调邮件工具 $\rightarrow$ 报错重试 $\rightarrow$ 成功）。</li>
<li><strong>输出:</strong> 在所有步骤都成功完成后，一次性返回最终结果（State 或 Dict）。</li>
</ol>
<h3 id="2-2-为什么它是-Agent-的首选？"><a href="#2-2-为什么它是-Agent-的首选？" class="headerlink" title="2.2 为什么它是 Agent 的首选？"></a>2.2 为什么它是 Agent 的首选？</h3><ul>
<li><strong>原子性保证:</strong> Agent 的中间步骤（如工具调用）通常是阻塞式的原子操作，无法流式传输。<code>invoke</code> 等待这些操作全部完成。</li>
<li><strong>内置容错:</strong> 如果 Agent 在第 2 步工具报错，它可以自动自我修正重跑第 3 步。<code>invoke</code> 会掩盖这些尴尬的错误过程，只给用户看最终成功的结论。</li>
</ul>
<h3 id="2-3-代码示例"><a href="#2-3-代码示例" class="headerlink" title="2.3 代码示例"></a>2.3 代码示例</h3><p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 定义 Agent</span><br><span class="line">agent_executor = AgentExecutor(agent=agent, tools=tools)</span><br><span class="line"></span><br><span class="line"># 同步调用</span><br><span class="line"># 程序会在此处“卡住”，直到 Agent 跑完所有逻辑</span><br><span class="line">result = agent_executor.invoke(&#123;&quot;input&quot;: &quot;查询上海明天的天气&quot;&#125;)</span><br><span class="line"></span><br><span class="line"># result 是一个包含完整上下文的字典</span><br><span class="line">print(f&quot;最终答案: &#123;result[&#x27;output&#x27;]&#125;&quot;)</span><br><span class="line">print(f&quot;中间步骤: &#123;result[&#x27;intermediate_steps&#x27;]&#125;&quot;) # 包含工具调用的详细历史</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-流式调用：agent-stream"><a href="#3-流式调用：agent-stream" class="headerlink" title="3. 流式调用：agent.stream()"></a>3. 流式调用：<code>agent.stream()</code></h2><p>对 Agent 使用流式调用比较复杂，因为 Agent 产生的数据流是<strong>混合的</strong>（Hybrid Stream）。</p>
<h3 id="3-1-核心逻辑"><a href="#3-1-核心逻辑" class="headerlink" title="3.1 核心逻辑"></a>3.1 核心逻辑</h3><p>当对 Agent 调用 <code>.stream()</code> 时，输出流中可能包含两种不同性质的数据块：</p>
<ol>
<li><strong>Final Answer Chunks:</strong> 最后生成给用户的自然语言（类似 ChatGPT 的打字机效果）。</li>
<li><strong>Intermediate Steps (可选):</strong> 如果配置了相关参数，可能会流出工具调用的动作（JSON 片段）或工具的返回结果。</li>
</ol>
<h3 id="3-2-两种流式策略"><a href="#3-2-两种流式策略" class="headerlink" title="3.2 两种流式策略"></a>3.2 两种流式策略</h3><p>在 Agent 开发中，我们需要区分“流式输出答案”和“流式展示思考过程”。</p>
<h4 id="策略-A-仅流式输出最终答案-Standard-Stream"><a href="#策略-A-仅流式输出最终答案-Standard-Stream" class="headerlink" title="策略 A: 仅流式输出最终答案 (Standard Stream)"></a>策略 A: 仅流式输出最终答案 (Standard Stream)</h4><p>这是最简单的用法。前端用户在等待期间看不到“正在搜索…”，但当 Agent 开始说话时，字是逐个蹦出来的。</p>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这种方式只会流式输出 Agent 决定“说话”时的内容</span><br><span class="line"># 在 Agent “做事”（调工具）期间，流是静默的</span><br><span class="line">for chunk in agent_executor.stream(&#123;&quot;input&quot;: &quot;给我讲个笑话&quot;&#125;):</span><br><span class="line">    # chunk 通常包含最终生成的文本片段</span><br><span class="line">    if &quot;output&quot; in chunk:</span><br><span class="line">        print(chunk[&quot;output&quot;], end=&quot;&quot;, flush=True)</span><br></pre></td></tr></table></figure>

<h4 id="策略-B-流式展示全过程-Stream-Events-v0-2-推荐"><a href="#策略-B-流式展示全过程-Stream-Events-v0-2-推荐" class="headerlink" title="策略 B: 流式展示全过程 (Stream Events - v0.2 推荐)"></a>策略 B: 流式展示全过程 (Stream Events - <strong>v0.2 推荐</strong>)</h4><p>如果你想实现类似 Kimi&#x2F;Perplexity 那种 <strong>“正在思考… 正在搜索 Google…”</strong> 的效果，标准的 <code>.stream()</code> 是不够的，需要使用 <strong><code>.stream_events()</code></strong> API。</p>
<p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 使用 astream_events 获取细粒度事件</span><br><span class="line">async for event in agent.astream_events(&#123;&quot;input&quot;: &quot;查天气&quot;&#125;, version=&quot;v1&quot;):</span><br><span class="line">    kind = event[&quot;event&quot;]</span><br><span class="line">    </span><br><span class="line">    if kind == &quot;on_chat_model_stream&quot;:</span><br><span class="line">        # LLM 正在生成 Token (可能是思考，可能是回答)</span><br><span class="line">        print(f&quot;Token: &#123;event[&#x27;data&#x27;][&#x27;chunk&#x27;].content&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">    elif kind == &quot;on_tool_start&quot;:</span><br><span class="line">        # Agent 决定调用工具了</span><br><span class="line">        print(f&quot;\n[正在调用工具]: &#123;event[&#x27;name&#x27;]&#125;...&quot;)</span><br><span class="line">        </span><br><span class="line">    elif kind == &quot;on_tool_end&quot;:</span><br><span class="line">        # 工具运行完毕</span><br><span class="line">        print(f&quot;\n[工具结果]: &#123;event[&#x27;data&#x27;].get(&#x27;output&#x27;)&#125;&quot;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-批量调用：agent-batch"><a href="#4-批量调用：agent-batch" class="headerlink" title="4. 批量调用：agent.batch()"></a>4. 批量调用：<code>agent.batch()</code></h2><p>用于高并发场景。LangChain 会利用线程池并行启动多个 Agent 实例（即并行的 ReAct Loop）。</p>
<h3 id="4-1-核心逻辑"><a href="#4-1-核心逻辑" class="headerlink" title="4.1 核心逻辑"></a>4.1 核心逻辑</h3><ul>
<li><strong>并行 Loop:</strong> 系统同时启动 N 个 <code>While</code> 循环。</li>
<li><strong>独立状态:</strong> 每个 Agent 维护自己独立的 Scratchpad（历史记录），互不干扰。</li>
<li><strong>木桶效应:</strong> 整体返回时间取决于“最费劲”的那个任务。</li>
</ul>
<h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><ul>
<li><strong>数据富集:</strong> 给 Excel 表里的 100 个公司名称，让 Agent 并行去 Google 搜索它们的 CEO 和 官网。</li>
<li><strong>自动化评测:</strong> 并行运行 50 个测试用例，评估 Agent 的准确率。</li>
</ul>
<h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><p>Python</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inputs = [</span><br><span class="line">    &#123;&quot;input&quot;: &quot;苹果公司的CEO是谁&quot;&#125;,</span><br><span class="line">    &#123;&quot;input&quot;: &quot;微软公司的CEO是谁&quot;&#125;,</span><br><span class="line">    &#123;&quot;input&quot;: &quot;英伟达公司的CEO是谁&quot;&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># max_concurrency 控制并发数，防止触发 API Rate Limit</span><br><span class="line">results = agent_executor.batch(inputs, config=&#123;&quot;max_concurrency&quot;: 5&#125;)</span><br><span class="line"></span><br><span class="line">for res in results:</span><br><span class="line">    print(res[&#x27;output&#x27;])</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-总结对比矩阵-Decision-Matrix"><a href="#5-总结对比矩阵-Decision-Matrix" class="headerlink" title="5. 总结对比矩阵 (Decision Matrix)"></a>5. 总结对比矩阵 (Decision Matrix)</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Invoke (同步)</strong></th>
<th><strong>Stream (流式)</strong></th>
<th><strong>Batch (批量)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Agent 视角</strong></td>
<td>启动一个闭环任务，直到完成。</td>
<td>启动任务，并实时广播内部产生的数据。</td>
<td>同时启动多个闭环任务。</td>
</tr>
<tr>
<td><strong>返回数据</strong></td>
<td>完整的最终状态 (<code>Dict</code>)</td>
<td>数据片段 (<code>Chunk</code>) 或 事件 (<code>Event</code>)</td>
<td>状态列表 (<code>List[Dict]</code>)</td>
</tr>
<tr>
<td><strong>前端体验</strong></td>
<td>用户需等待 Loading 圈转完。</td>
<td>1. 打字机效果 (Final Answer) 2. 步骤进度条 (Stream Events)</td>
<td>通常用于后台，无前端交互。</td>
</tr>
<tr>
<td><strong>开发复杂度</strong></td>
<td>⭐ (简单，推荐默认使用)</td>
<td>⭐⭐⭐ (复杂，需解析混合流)</td>
<td>⭐⭐ (中等，需关注并发限制)</td>
</tr>
<tr>
<td><strong>最佳场景</strong></td>
<td><strong>工具执行、复杂任务交付</strong></td>
<td><strong>聊天机器人、长文本生成</strong></td>
<td><strong>数据清洗、批量爬虫</strong></td>
</tr>
</tbody></table>
<h2 id="6-专家建议-Best-Practices"><a href="#6-专家建议-Best-Practices" class="headerlink" title="6. 专家建议 (Best Practices)"></a>6. 专家建议 (Best Practices)</h2><ol>
<li><strong>默认使用 <code>invoke</code>:</strong> 除非你有明确的理由（如降低首字延迟），否则 Agent 开发应默认使用 <code>invoke</code>。它能保证逻辑完整性，且屏蔽了大量脏数据。</li>
<li><strong>UI 展示用 <code>stream_events</code>:</strong> 如果产品经理要求展示 Agent 的“思考过程”（UI 上的动态步骤卡片），不要费力去解析 <code>.stream()</code> 的原始字符串，直接使用 <code>.stream_events()</code> API，它是专门为此设计的。</li>
<li><strong>注意 <code>batch</code> 的消耗:</strong> Agent 的 <code>batch</code> 消耗是惊人的。如果 1 个任务循环 5 次，<code>batch(10)</code> 就意味着短时间内触发 50 次 LLM 调用和 50 次工具调用，极易触发 API 风控。务必设置 <code>max_concurrency</code>。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Zed</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/">http://example.com/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/langchain/">langchain</a><a class="post-meta__tags" href="/tags/llm/">llm</a></div><div class="post-share"><div class="social-share" data-image="/img/asuka.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">langchain标准化prompt</div></div><div class="info-2"><div class="info-item-1">1. 问题背景 (Problem Statement)在传统软件工程中，标准化依赖于精确的语法（Syntax）和强类型系统。而在基于 LangChain 的 LLM 应用开发中，核心逻辑依赖于自然语言（Prompts 和 Tool Descriptions）。 面临的挑战：  不确定性： 自然语言具有歧义性，导致系统行为难以像传统代码那样 100% 预测。 非标化： 不同的开发者编写 Prompt 的质量参差不齐，导致系统稳定性波动。  核心论点： LangChain 无法消除对 Prompt 的依赖（这是 LLM 的物理特性），但它提供了一套工程化框架，将模糊的自然语言逻辑包裹在标准化的软件架构中。  2. 范式转移：自然语言作为新汇编 (The Paradigm Shift)在 AI 工程中，我们需要重新映射编程概念：    传统编程概念 AI 工程对应物 本质变化    函数签名 (Signature) 工具描述 (Description) 从“类型匹配”变为“语义理解”。   业务逻辑 (Logic) Prompt Template 从“流程控制...</div></div></div></a><a class="pagination-related" href="/2026/01/11/Python-%E6%A8%A1%E5%9D%97%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97-PEP-257/" title="Python 模块文档字符串规范指南 (PEP 257)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Python 模块文档字符串规范指南 (PEP 257)</div></div><div class="info-2"><div class="info-item-1">这是一份基于 PEP 257 标准编写的 Python 模块文档字符串 (Module Docstrings) 技术规范文档。 1. 简介文档字符串（Docstring）是出现在模块、函数、类或方法定义中的第一个语句（字符串字面量）。Python 编译器会自动将该字符串识别为文档，并赋值给对象的 __doc__ 属性。 本指南专门针对 模块（Module） 级别的文档字符串规范进行说明。 2. 核心原则 必须使用三双引号：无论文档只有一行还是多行，始终使用 &quot;&quot;&quot; 包裹文档字符串。不要使用单引号 &#39;&#39;&#39;。 位置必须置顶：模块文档字符串必须是文件中的第一个语句（在 import 之前，但在 shebang #! 和编码声明之后）。 句号结尾：摘要行必须以句号（英文 . 或中文 。）结尾。  3. 两种格式规范3.1 单行文档 (One-line Docstrings)适用于功能非常简单明显的模块。  规范：  整个文档（包括引号）必须在同一行。 前后引号与文本之间不要有空格。 必须是对功能的描述性短语（”Do...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">langchain标准化prompt</div></div><div class="info-2"><div class="info-item-1">1. 问题背景 (Problem Statement)在传统软件工程中，标准化依赖于精确的语法（Syntax）和强类型系统。而在基于 LangChain 的 LLM 应用开发中，核心逻辑依赖于自然语言（Prompts 和 Tool Descriptions）。 面临的挑战：  不确定性： 自然语言具有歧义性，导致系统行为难以像传统代码那样 100% 预测。 非标化： 不同的开发者编写 Prompt 的质量参差不齐，导致系统稳定性波动。  核心论点： LangChain 无法消除对 Prompt 的依赖（这是 LLM 的物理特性），但它提供了一套工程化框架，将模糊的自然语言逻辑包裹在标准化的软件架构中。  2. 范式转移：自然语言作为新汇编 (The Paradigm Shift)在 AI 工程中，我们需要重新映射编程概念：    传统编程概念 AI 工程对应物 本质变化    函数签名 (Signature) 工具描述 (Description) 从“类型匹配”变为“语义理解”。   业务逻辑 (Logic) Prompt Template 从“流程控制...</div></div></div></a><a class="pagination-related" href="/2026/01/11/langSmith%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="langSmith功能与工作流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">langSmith功能与工作流</div></div><div class="info-2"><div class="info-item-1">这份文档为您总结了 LangSmith 的核心技术能力及其在 LLM 应用开发全生命周期中的工作流。 1. 核心定位LangSmith 是一个用于构建生产级 LLM 应用程序的 DevOps 平台。它弥补了传统软件开发工具在面对非确定性 LLM 时的不足，提供从原型开发、调试、评估到生产监控的全链路支持。  2. 核心功能详解 (Core Capabilities)2.1 全链路追踪与调试 (Tracing &amp; Debugging)解决 LLM 应用的“黑盒”问题，提供极其细颗粒度的可视性。  功能描述： 自动记录每一次 LLM 调用、Chain 执行、Agent 思考过程及 Tool 使用。 关键特性： 可视化调用树 (Run Tree)： 以层级结构展示调用链，清晰查看输入、输出、Prompt 渲染结果。 瀑布流视图 (Waterfall)：  可视化每个步骤的延迟，快速定位是检索慢还是生成慢。 元数据捕获： 自动记录 Token 消耗、模型参数、延迟和错误堆栈。 Playground 集成： 在 Trace 界面直接修改 Prompt 参数并“重放”...</div></div></div></a><a class="pagination-related" href="/2026/01/10/ReAct/" title="ReAct"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-10</div><div class="info-item-2">ReAct</div></div><div class="info-2"><div class="info-item-1">这是一份关于 ReAct (Reasoning + Acting) 技术的深度技术白皮书。它涵盖了从核心原理、底层实现到进阶架构的完整知识体系。 1. 核心定义与背景 (Introduction)ReAct 是 Reasoning（推理） 与 Acting（行动） 的合成词。它是一种用于构建大语言模型（LLM）代理（Agent）的范式。  起源: Google Research (Yao et al., 2022) 提出的论文 “ReAct: Synergizing Reasoning and Acting in Language Models”。 解决的问题: 单纯的 推理 (Chain-of-Thought) 容易产生幻觉，无法获取外部世界的新知。 单纯的 行动 (Action) 缺乏规划，容易在复杂任务中迷失方向。   核心理念: 让 LLM 在执行任务时，交替进行“思考（生成推理轨迹）”和“行动（调用外部工具）”，并将行动的结果（观察）反哺给模型，形成闭环。   2. 技术架构与工作流 (Architecture &amp; Workflow)ReAct...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zed</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ze-d"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">welcome to my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-Overview"><span class="toc-number">1.</span> <span class="toc-text">1. 概述 (Overview)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%EF%BC%9Aagent-invoke"><span class="toc-number">2.</span> <span class="toc-text">2. 同步调用：agent.invoke()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF-Agent-%E7%9A%84%E9%A6%96%E9%80%89%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 为什么它是 Agent 的首选？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%81%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9Aagent-stream"><span class="toc-number">3.</span> <span class="toc-text">3. 流式调用：agent.stream()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%A4%E7%A7%8D%E6%B5%81%E5%BC%8F%E7%AD%96%E7%95%A5"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 两种流式策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-A-%E4%BB%85%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA%E6%9C%80%E7%BB%88%E7%AD%94%E6%A1%88-Standard-Stream"><span class="toc-number">3.2.1.</span> <span class="toc-text">策略 A: 仅流式输出最终答案 (Standard Stream)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-B-%E6%B5%81%E5%BC%8F%E5%B1%95%E7%A4%BA%E5%85%A8%E8%BF%87%E7%A8%8B-Stream-Events-v0-2-%E6%8E%A8%E8%8D%90"><span class="toc-number">3.2.2.</span> <span class="toc-text">策略 B: 流式展示全过程 (Stream Events - v0.2 推荐)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%B9%E9%87%8F%E8%B0%83%E7%94%A8%EF%BC%9Aagent-batch"><span class="toc-number">4.</span> <span class="toc-text">4. 批量调用：agent.batch()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E7%9F%A9%E9%98%B5-Decision-Matrix"><span class="toc-number">5.</span> <span class="toc-text">5. 总结对比矩阵 (Decision Matrix)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%93%E5%AE%B6%E5%BB%BA%E8%AE%AE-Best-Practices"><span class="toc-number">6.</span> <span class="toc-text">6. 专家建议 (Best Practices)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langSmith%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81/" title="langSmith功能与工作流">langSmith功能与工作流</a><time datetime="2026-01-11T10:02:41.000Z" title="Created 2026-01-11 18:02:41">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/Python-%E6%A8%A1%E5%9D%97%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97-PEP-257/" title="Python 模块文档字符串规范指南 (PEP 257)">Python 模块文档字符串规范指南 (PEP 257)</a><time datetime="2026-01-11T09:22:35.000Z" title="Created 2026-01-11 17:22:35">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langchain%E4%B8%ADAgent%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F/" title="langchain中Agent的三种调用方式">langchain中Agent的三种调用方式</a><time datetime="2026-01-11T07:11:37.000Z" title="Created 2026-01-11 15:11:37">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/11/langchain%E6%A0%87%E5%87%86%E5%8C%96prompt/" title="langchain标准化prompt">langchain标准化prompt</a><time datetime="2026-01-11T04:32:42.000Z" title="Created 2026-01-11 12:32:42">2026-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/10/ReAct/" title="ReAct">ReAct</a><time datetime="2026-01-10T14:11:32.000Z" title="Created 2026-01-10 22:11:32">2026-01-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bkground.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By Zed</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>