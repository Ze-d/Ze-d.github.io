---
title: k8s简介
date: 2025-12-04 11:18:48
tags: k8s
---

好的，我们来详细介绍一下 **Kubernetes**。

Kubernetes（通常简称为 **K8s**，“K”和“s”之间有8个字母）是一个开源的**容器编排平台**，用于自动化部署、扩展和管理容器化应用。它由Google在2014年开源，其设计灵感来源于Google内部运行了十余年的Borg系统。如今，K8s已成为云原生时代的基石和事实标准。

### 一、核心比喻：从“手动管理集装箱”到“智能物流中心”
想象一下早期运输业：
*   **传统部署（物理机/虚拟机时代）：** 就像在不同港口，用不同规格的卡车、轮船，手动搬运大小不一的货物。效率低，容易出错，难以扩展。
*   **容器化时代（只有Docker）：** 我们发明了**标准集装箱（容器）**。所有货物都放在统一的集装箱里，搬运变得容易。但问题来了：成千上万个集装箱分散在全球，谁来调度哪艘船运哪个箱？哪个港口有闲置位置？如何保证某个箱子的损坏能自动替换？
*   **Kubernetes时代：** 它就是一个**全球智能物流与调度中心**。你只需告诉它：“我需要将1000个‘A产品’集装箱运到亚洲，并始终保持有100个在运行。” K8s就会自动完成所有工作：选择最合适的货轮（服务器）、规划路线、监控状态、处理故障、动态扩容缩容。**你就是这个物流中心的“总指挥”，只关心最终状态（声明式API），而不必亲自操作吊车。**

### 二、为什么需要Kubernetes？它解决的核心问题
随着微服务架构和容器（尤其是Docker）的普及，应用被拆分成数十甚至数百个松散耦合的容器。手动管理这些容器几乎是不可能的，主要面临：
1.  **编排与调度**：成百上千的容器，应该部署在哪台机器上？
2.  **服务发现与负载均衡**：容器A如何找到并调用动态创建的容器B？
3.  **自愈与高可用**：当某个容器或机器故障时，如何自动重启或迁移容器？
4.  **弹性伸缩**：流量高峰时如何自动增加容器实例？低峰时如何回收资源？
5.  **配置与密钥管理**：如何安全地向容器分发配置文件和密码？
6.  **滚动更新与回滚**：如何在不中断服务的情况下升级应用？出问题如何快速回退？

**Kubernetes 就是为了系统性地解决上述所有问题而生的。**

### 三、核心架构与概念
K8s集群由两部分组成：**控制平面（Master Node）** 和**工作节点（Worker Node）**。

#### **控制平面（大脑）**
负责整个集群的决策和管理。
*   **API Server**：集群的“前台”和唯一入口。所有用户、命令行工具、其他组件都通过它来操作集群。
*   **etcd**：一个高可用的键值数据库，存储着集群所有配置数据和状态（如Pod、Service等信息）。它是K8s的“记忆库”。
*   **Scheduler**：调度器，负责决定将新创建的Pod（容器组）放到哪个合适的Node上运行。
*   **Controller Manager**：控制器管理器，包含多种控制器，如节点控制器、副本控制器等，它们不断循环，确保集群的实际状态符合用户声明的期望状态。

#### **工作节点（肢体）**
负责运行容器。
*   **Kubelet**：节点上的“代理”，负责与API Server通信，管理本节点上Pod的生命周期（创建、停止容器），并报告节点状态。
*   **Kube Proxy**：维护节点上的网络规则，实现Service的负载均衡和网络代理。
*   **容器运行时**：负责运行容器的软件，如Docker、containerd等。

#### **核心抽象概念（理解这些是关键）**
1.  **Pod**：**K8s可管理的最小、最简单的单元**。一个Pod通常包含一个或多个紧密关联的容器（如主应用容器和日志收集Sidecar容器），它们共享网络、存储和生命周期。Pod是临时性的，会被频繁创建和销毁。
2.  **Deployment**：**最常用的控制器**。它定义了Pod的“期望状态”（如运行3个副本），并负责以可控的方式（滚动更新）更新Pod，确保任何时刻都有指定数量的Pod在运行。它管理的是无状态应用。
3.  **Service**：**定义了一组Pod的稳定访问入口**。由于Pod是动态的，IP地址会变，Service提供一个固定的IP地址和DNS名称，并负责将流量负载均衡到后端的Pod集合。它是服务发现的核心。
4.  **ConfigMap & Secret**：将配置信息（如配置文件）和敏感信息（如密码、令牌）与容器镜像解耦，以键值对的形式存储，并安全地注入到Pod中使用。
5.  **Namespace**：在物理集群内部创建的虚拟集群，用于将资源（如Pod、Service）隔离成不同的逻辑分组（例如：开发环境、生产环境）。
6.  **Volume**：为Pod提供持久化存储的抽象。即使Pod被重启或迁移，数据也能得以保留。

### 四、一个简单的工作流程示例
假设你要部署一个Web应用：
1.  **定义**：你编写一个YAML文件（例如 `myapp-deployment.yaml`），声明你需要一个名为 `myapp` 的 `Deployment`，包含3个副本，每个副本是一个运行你Web应用镜像的Pod。
2.  **提交**：通过 `kubectl apply -f myapp-deployment.yaml` 命令，将文件提交给API Server。
3.  **调度**：Scheduler发现3个待创建的Pod，根据资源情况，将它们分配到合适的Node 1和Node 2上。
4.  **执行**：目标Node上的Kubelet收到指令，拉取镜像，启动容器。
5.  **暴露**：你创建一个 `Service` YAML文件，定义如何访问这些 `myapp` Pod。Kube-proxy会为这个Service配置负载均衡规则。
6.  **维持**：Deployment的控制器会持续监控，确保始终有3个健康的Pod在运行。如果一个Pod崩溃，它会立即启动一个新的。

### 五、优点与挑战
**优点：**
*   **基础设施抽象**：开发者聚焦应用，无需关心底层服务器。
*   **声明式API与自动化**：“描述最终状态”，系统自动实现和维持。
*   **卓越的弹性与自愈能力**：自动处理故障，保障服务高可用。
*   **丰富的生态系统**：拥有庞大的工具链和社区支持（Helm、Operators、Istio等）。
*   **跨云与混合云**：一套系统可以运行在公有云、私有云或混合环境，避免供应商锁定。

**挑战/复杂度：**
*   **学习曲线陡峭**：概念繁多，架构复杂。
*   **运维复杂度高**：自建K8s集群需要专业的运维知识。
*   **安全配置**：默认配置并非最安全，需要精心配置策略（如Network Policies, RBAC）。
*   **成本**：虽然节省了人力，但控制平面和分布式系统本身有资源开销。

### 六、总结
**Kubernetes 是云原生时代的操作系统。** 它不再是简单地运行容器，而是提供了一个完整的平台，用于管理以容器为中心的微服务架构，实现了应用的自动化部署、规模化运维和高效调度。

对于企业而言，采用K8s意味着获得了快速交付软件、高效利用硬件资源和构建健壮、可扩展应用的能力。虽然入门有门槛，但它已成为现代IT基础设施中不可或缺的核心组件。现在主流的公有云（如AWS EKS， Google GKE， Azure AKS， 阿里云ACK）都提供了托管的K8s服务，大大降低了使用门槛。
