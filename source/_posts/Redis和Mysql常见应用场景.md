---
title: Redis和Mysql常见应用场景
date: 2025-12-12 16:44:20
tags: [Database,Redis Mysql]
---

先把结论说在前面一句话里：

> **MySQL 负责“可靠存数据、复杂查询”，Redis 负责“高性能的缓存和少量高频小数据”。**
>  很多系统里，两者是搭配使用，而不是二选一。

下面我分三块讲：

1. 从“理论特性”上怎么区分 Redis 和 MySQL
2. 常见业务场景下该用谁、怎么配合用
3. 几个实战中的判断准则（给你一些“拍板规则”）

------

## 1. 理论层面的区别：Redis vs MySQL 到底差在哪

### 1.1 存储类型与数据模型

**MySQL：关系型数据库**

- **有表结构（Schema）**：行、列，列类型固定（int、varchar、datetime…）
- 支持 **SQL 查询**：`SELECT ... WHERE ... JOIN ... GROUP BY ...`
- 非常适合：
  - 结构化、关系复杂的数据
  - 需要各种统计、条件过滤、排序、分页、关联查询的场景

**Redis：内存数据结构存储**

- 以 **Key-Value** 为基础，但 Value 可以是丰富的数据结构：
  - String、Hash、List、Set、Sorted Set、Bitmap、HyperLogLog、Stream 等
- 不支持 SQL，只能基于 Key 和单数据结构的原语操作（`GET/SET/HSET/ZADD` 之类）
- 适合：
  - 访问模式相对简单（按 Key 查，少量字段操作）
  - 更多是 **“记一个状态 / 结果 / 计数 / 排名”** 这类诉求

> 总结：**要复杂查询 → MySQL；
>  要搞简单且高频的“状态、计数、缓存” → Redis。**

------

### 1.2 性能：延迟和吞吐

**Redis 性能特点**

- 数据在内存中，单机 QPS **几十万级** 很常见
- 单次访问延迟一般在 **微秒到几毫秒**
- 运算多是 O(1) 或接近 O(1)，适合作为高频热点数据层

**MySQL 性能特点**

- 数据落在磁盘（+缓存），单机 QPS 一般在 **几千到上万级**（视索引、硬件、SQL 而定）
- 支持复杂 SQL，所以执行计划会更复杂，也更慢
- 依赖索引和表设计，峰值性能不如 Redis，但胜在功能全面

> 总结：
>
> - **超高 QPS / 超低延迟 的访问，优先考虑 Redis。**
> - 日志型、报表型、不那么频繁的业务读写，用 MySQL 完全没问题。

------

### 1.3 一致性、事务和可靠性

**MySQL：强一致 + ACID**

- 提供 **事务 ACID**：
  - 原子性、一致性、隔离性、持久性
- 对 **金融、订单、库存** 等对准确性要求极高的场景，是主力数据库
- 崩了可以通过 binlog、redo log 持久化恢复

**Redis：高性能 + 可选持久化，但不是强事务 DB**

- Redis 有事务（`MULTI/EXEC`），但：
  - 不支持回滚（只是顺序执行命令）
  - 更偏向于“指令打包执行”，防止并发交织
- 支持 RDB、AOF 持久化，但：
  - 默认目标是“降低丢数据概率”，而**不是** 完全不丢
  - 在突发宕机时，可能丢失最近一小段的数据

> 结论：
>
> - **需要强一致和稳定持久化：首选 MySQL。**
> - Redis 在重要数据上一般作为“副本（缓存 + 热点）”，真正的“账本”还是 MySQL。

------

### 1.4 CAP 取舍和典型部署

- **MySQL** 在单机或主从模式下更偏向 **CP**：
  - 要保证数据一致性，遇到网络分区往往宁愿拒绝写入
- **Redis 集群** 通常则更偏向 **AP**（尤其是一些哨兵、集群模式）：
  - 更追求可用性和性能，一致性由业务自己兜底

> 简单说：
>
> - **账务、订单、用户资产 → MySQL 扛着；**
> - **计数、排名、会话、缓存、推荐结果等热点 → Redis 扛着。**

------

## 2. 典型应用场景：什么时候用 Redis，什么时候用 MySQL？

### 2.1 Redis 适用场景

我先列常见的，然后每个给你一句“为啥”。

#### ① 缓存（最典型）

**场景**：页面详情、配置、用户信息、商品信息、首页推荐列表
 **模式**：

- 缓存读：`Redis（miss）→ MySQL → 回填 Redis`
- 缓存写：`MySQL 更新成功后 → 删除/更新 Redis 中的缓存`

**为什么**：

- 减轻数据库读压力（某些热点接口 QPS 能从 1w 变 100w）
- 降低响应时间，提高用户体验

> ✱ 典型模式：
>
> - **缓存 Aside（旁路缓存）**：先读缓存，缓存 miss 再读 DB + 回填
> - 业务核心数据：**写 DB，再删缓存**（避免缓存与 DB 长期不一致）

------

#### ② 分布式 Session / Token 存储

**场景**：

- 登录态、Session 信息（用户ID、权限、过期时间）
- 单点登录（SSO）、微服务网关的 Token 验证

**为什么**：

- Session/Token 访问非常频繁、数据量不大
- 需要天然的过期机制（Redis TTL 非常好用）
- 多机共享，避免“粘在一台应用机器上”

------

#### ③ 计数器、点赞、浏览量、限流

**场景**：

- 点赞数、阅读数、收藏数、转发数
- 接口限流：某 IP 每分钟访问次数
- PV/UV 统计（UV 可用 Bitmap）

**为什么**：

- 这些数据的特点：**频繁+简单+对极致准确度不敏感（通常可以异步回写）**
- Redis 的自增、自减操作（`INCR/DECR/HINCRBY`）是原子且超快

典型用法：

```text
文章浏览量：Redis 累加 → 定期异步批量回写 MySQL
接口限流：请求前先检查 Redis 中该 IP 的计数
```

------

#### ④ 排行榜 / 排队系统

**场景**：

- 游戏积分排行榜
- 热点文章/视频排行榜
- 秒杀排队优先级、抢购排名

**核心结构**：**Sorted Set（有序集合）**

- `ZADD`：添加成员 + 分数
- `ZREVRANGE`：获取 top N

**为什么要 Redis**：

- Sorted Set 原生支持按分数排序与范围查询
- 内存结构 + 专门操作 → 性能远高于“用 SQL 排序 TOP N”

------

#### ⑤ 分布式锁

**场景**：

- 防止多个服务实例同时处理同一订单
- 防重操作（支付、创建订单、发货）
- 限制某个共享资源同一时间只能被一个客户端使用

**为什么**：

- Redis 的 `SET key value NX EX` 可以实现简单的分布式锁
- 借助 RedLock 或自己实现的一些机制，可以做到高可用、高性能的锁

> 注意：**Redis 分布式锁 ≠ 强一致锁，适合高性能、业务可容忍少数情况的“幂等 +补偿”方案。
>  金融级一致性锁还是要谨慎设计。**

------

#### ⑥ 发布 / 订阅、实时消息

**场景**：

- 简单的实时通知、聊天室、消息分发
- 配合 Stream 做日志流、消费队列

**为什么**：

- Redis Pub/Sub / Stream 实现轻量消息通道
- 尤其适合“高吞吐 + 可接受当个别消息丢失”的业务

> 如需严格可靠队列，还是要上 Kafka / RabbitMQ 之类的专业 MQ。

------

### 2.2 MySQL 适用场景

#### ① 核心业务数据：订单、支付、用户、库存…

**场景**：电商、支付、账号系统、资产系统
 **特点**：

- 强一致性，不能乱
- 需要事务（比如扣库存 + 写订单 + 写流水）

**理由**：

- MySQL 支持 **事务 + 行级锁 + 外键约束**
- 有完善的 **日志机制（redo、binlog）** 保证恢复能力
- 支持丰富 SQL 为报表、风控、对账提供基础

------

#### ② 多维度查询与报表分析

**场景**：

- 后台报表：按时间、用户、地区、渠道统计
- 模糊查询、多条件组合过滤、复杂排序分页
- 各种 JOIN：用户表 + 订单表 + 商品表等

**理由**：

- MySQL 能利用索引和优化器处理复杂 SQL
- Redis 不支持 JOIN，模拟 JOIN 成本高，逻辑复杂，维护困难

------

#### ③ 中长期业务历史记录

**场景**：

- 历史订单、操作日志、审计记录
- 即使很久不访问，也必须要保存
- 数据量可以非常大（千万、上亿）

**理由**：

- Redis 内存成本过高，不适合存巨大历史数据
- MySQL 可以搭配冷热分库、分表、归档方案来支撑长期存储

------

#### ④ 后台管理系统 & 运维查询

**场景**：

- 后台管理页面：查询用户、订单、统计报表
- 运维 DBA 日常的数据巡检、异常排查

**理由**：

- 各种 ad-hoc SQL 查询都需要 DB 做支撑，Redis 做不到
- DBA 的工作都是围绕 MySQL 或其他数据库进行

------

### 2.3 Redis + MySQL 一起用的典型组合

很多系统的模式其实是：

> **MySQL 做“真相数据源（Source of Truth）”，Redis 做“加速层 + 状态层”。**

常见组合示例：

#### 组合 1：数据缓存

- 写：
  1. 业务更新 MySQL
  2. 操作成功后，删除或更新 Redis 缓存
- 读：
  1. 优先查 Redis
  2. 没有的话查 MySQL 并写入 Redis

------

#### 组合 2：计数 & 回写

- Redis 维护计数，提供实时访问
- 定时 Job 或异步消息，将计数累积值回写 MySQL

好处：

- 对外提供“看起来实时”的数值
- 实际上 MySQL 中偶尔慢一点更新没关系

------

#### 组合 3：Session 存 Redis，用户基础信息在 MySQL

- 登录时验证账号密码 → MySQL
- 登录成功后在 Redis 中写 Session/Token
- 之后多数请求都只访问 Redis 校验 Token + 载入必要信息

------

## 3. 实战中的判断准则：你实际写代码时怎么拍板？

可以用下面这几个问题来快速判断：

### 问题 1：这个数据丢失一小部分可以接受吗？

- **不能接受 → 必须 MySQL**（再加缓存也行）
  - 比如：订单、支付记录、币余额、成绩单、发票信息
- **偶尔丢一小部分没事 / 能重算 → 可以用 Redis 为主，MySQL 辅助**
  - 比如：PV 统计、推荐候选集合、排行榜缓存、临时 token

------

### 问题 2：访问是否非常频繁，对延迟是否极为敏感？

- **非常频繁 + 要极低延迟 → Redis**
  - 配置、热点商品、用户 Session、首页推荐列表
- 访问频率一般，不是性能瓶颈 → 直接 MySQL 就够用

------

### 问题 3：是否需要复杂查询、过滤、统计、关联？

- 需要：
  - 多条件检索
  - 模糊搜索（`LIKE`）、范围查询
  - JOIN 多张表
     → **用 MySQL**，Redis 模拟这些会非常痛苦
- 不需要：
  - 基本就是按 Key 查单条记录
  - 或根据一个简单的排序/计数规则取 Top N
     → Redis 很适合

------

### 问题 4：数据量是否巨大，且需要长期保存？

- 是：
  - 上亿历史记录
  - 审计、法务要求保存 N 年
     → **MySQL（或其他持久 DB）**，内存数据库不适合
- 否：
  - 数据规模中等或可定期清理
     → Redis 可以用，注意设置 TTL 或做定期清理

------

### 问题 5：数据结构是否天然适合 Redis？

- 天生适合 Redis 的例子：
  - 排行榜（Sorted Set）
  - 好友关系（Set）
  - 消息流（List/Stream）
  - 布隆过滤器/Bitmap/频率统计
- 这些用关系型去做容易写得很绕、性能也一般，这种场景 Redis 的性价比更高。

------

## 4. 一个小总结表（方便你记忆）

| 维度           | Redis                             | MySQL                              |
| -------------- | --------------------------------- | ---------------------------------- |
| 数据模型       | 内存 Key-Value，多种结构          | 关系型，表/行/列                   |
| 查询能力       | 按 Key 和结构操作，简单范围       | SQL，JOIN，聚合，复杂查询          |
| 性能(QPS/延迟) | 极高 QPS，极低延迟                | 中等 QPS，延迟略高                 |
| 持久化         | 有，但不是绝对不丢                | 强持久化，崩溃后可恢复             |
| 事务能力       | 简单事务，无回滚                  | 完整 ACID 事务                     |
| 适合场景       | 缓存、Session、计数器、排行榜、锁 | 订单、支付、库存、用户、报表、审计 |
| 数据规模       | 适合中小规模、热点数据            | 适合长期、海量、历史数据           |
| 异常容错       | 少量丢失一般业务可兜底            | 丢失即事故，需要高可靠配置         |

------

如果你愿意，你可以把你现在正在做的系统/项目简单描述一下（比如电商、内容平台、IoT 平台、跑步社区之类），我可以针对你具体业务，帮你画一张“Redis + MySQL”职责划分图和推荐表结构/Key 设计。
