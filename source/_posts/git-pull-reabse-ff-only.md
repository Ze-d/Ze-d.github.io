---
title: git pull,--reabse,--ff-only
date: 2025-12-19 17:00:05
tags: Git
---

Git Pull 策略详解：Merge vs Rebase vs FF-only

当你执行 `git pull` 时，你实际上是在做两件事：

1. **`git fetch`**：把远程仓库的最新代码拉取到本地（但不合并）。
2. **`Integration`**：将拉取下来的代码与你当前的工作成果“整合”。

**三种命令的区别，仅仅在于第 2 步“整合”的方式不同。**

## 1. 核心对比速查表

假设场景：远程有新提交 `B`，你本地也有新提交 `C`（即**历史分叉**）。

| **命令**     | **git pull (默认)**      | **git pull --rebase**          | **git pull --ff-only**       |
| ------------ | ------------------------ | ------------------------------ | ---------------------------- |
| **整合策略** | **Merge (合并)**         | **Rebase (变基)**              | **Fast-forward (仅快进)**    |
| **历史形状** | 分叉并汇合 (菱形结构)    | 一条直线                       | 保持原样 (因为会报错中止)    |
| **提交数量** | 增加一个 Merge Commit    | 数量不变 (Commit Hash 会变)    | 无变化                       |
| **主要优点** | 真实记录历史发生的时间线 | 历史干净整洁，无多余合并点     | 最安全，防止意外合并         |
| **主要缺点** | 历史线混乱，也就是“脏”   | 解决冲突稍繁琐，修改了提交哈希 | 遇到分叉就罢工，需要人工干预 |

------

## 2. 详细原理解析

### A. `git pull` (默认行为)

> **策略：** 能快进就快进；不能快进就创建“合并提交”。

- **原理：** 类似于 `git fetch` + `git merge`。

- **当遇到分叉时：** 它会创建一个新的 **Merge Commit**（通常名为 `Merge branch 'master' of...`），将远程分支和本地分支“绑”在一起。

- **适用场景：** 你不介意历史记录中有分叉和合并点，或者你正在合并一个长期的大型分支。

- **图示：**

  Plaintext

  ```
        A---B (远程)
       /     \
  D---E-------M (本地，M 是生成的 Merge Commit)
       \     /
        C---F (本地原提交)
  ```

### B. `git pull --rebase`

> **策略：** 我先撤，让远程代码先走，我排在最后。

- **原理：** 类似于 `git fetch` + `git rebase`。

- **当遇到分叉时：**

  1. 把你的本地提交（未推送的）临时“剪切”下来。
  2. 把远程代码更新到本地。
  3. 把你的提交重新“粘贴”到最顶端（Replay）。

- **适用场景：** 日常在 Feature 分支开发。这是保持代码提交线呈**直线**的最佳方式。

- **图示：**

  Plaintext

  ```
  (操作前)      A---B (远程)
               /
          D---E---C (本地)
  
  (操作后) D---E---A---B---C' (本地，C 变成了 C'，接在 B 后面)
  ```

### C. `git pull --ff-only`

> **策略：** 只有在“绝对安全”且“无需合并”的情况下才更新。

- **原理：** 强制要求 Git 只能进行 **Fast-forward**（指针直接向前移动）。
- **当遇到分叉时：** **直接报错并停止** (`fatal: Not possible to fast-forward, aborting`)。它拒绝帮你自动处理分叉。
- **适用场景：**
  - **更新主分支 (Master/Main)：** 你不应该在本地 Main 分支直接提交代码，所以如果更新 Main 时报错，说明你违规操作了，这是一个很好的“警报器”。
  - **自动化脚本 (CI/CD)：** 防止脚本在无人值守时产生意外的 Merge Commit。

------

## 3. 决策指南：我该用哪个？

请根据你当前的分支类型来选择：

#### 场景 1：我在自己的功能分支 (Feature Branch) 上开发

**推荐：** **`git pull --rebase`**

- **理由：** 你的功能分支最终是要合并回主干的。在开发过程中使用 rebase 拉取主干代码，可以让你的分支历史保持干净，合并回主干时更轻松，且不会产生无数个无意义的 "Merge remote-tracking branch" 提交。

#### 场景 2：我在更新公共主分支 (Main/Master/Develop)

**推荐：** **`git pull --ff-only`**

- **理由：** 本地的公共分支应该永远与远程保持严格同步，不应包含你个人的“私货”。如果不小心在 Main 上提交了代码，`--ff-only` 会报错提醒你，防止你把本地的测试代码意外混合进主干。

####  场景 3：我不熟悉 Git，害怕丢失代码

**推荐：** **`git pull` (默认)**

- **理由：** 虽然它会生成丑陋的 Merge Commit，但它是破坏性最小的。它绝对不会修改你已有的 Commit ID，也就是“最诚实”的记录方式。

------

### 进阶：如何设置全局默认？

如果你想省去每次打参数的麻烦，可以配置 Git 的默认行为。

**选项 1：总是默认使用 Rebase (这也是很多资深开发者的设置)**

Bash

```
git config --global pull.rebase true
```

*这样你只需输入 `git pull`，它就会自动执行 rebase。*

**选项 2：总是默认使用 ff-only (严格模式)**

Bash

```
git config --global pull.ff only
```

*这样 `git pull` 遇到分叉就会报错，强迫你手动决定是 merge 还是 rebase。*
