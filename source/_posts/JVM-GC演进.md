---
title: JVM GC演进
date: 2025-12-23 17:51:30
tags: java
---

这是一份经过深度整合的技术文档，涵盖了 JVM 垃圾回收（GC）的演进历史、硬件驱动因素、核心算法实现及对比分析。你可以直接复制以下 Markdown 内容。

------

# JVM 垃圾回收（GC）体系架构演进与技术实现

## 1. 概述：GC 的核心矛盾与演进逻辑

JVM 垃圾回收器的演进史，本质上是**计算硬件发展（摩尔定律）\**与\**业务形态变化**共同驱动的结果。其核心矛盾始终围绕着两个指标的权衡：

1. **吞吐量 (Throughput)**：用户代码运行时间 / (用户代码运行时间 + GC 运行时间)。
2. **延迟 (Latency)**：垃圾收集时造成的应用暂停时间（Stop The World, STW）。

- **演进趋势**：从追求最大吞吐量，逐渐转向追求极致的可预测低延迟。
- **硬件背景**：内存从 MB 级扩展至 TB 级；CPU 从单核演进至多核 NUMA 架构。

------

## 2. 基础理论：分代收集 (Generational Hypothesis)

绝大多数 GC（除 ZGC/Shenandoah 的部分模式外）都遵循分代假设：

1. **弱分代假说**：绝大多数对象都是朝生夕死的（分配后很快变为垃圾）。
2. **强分代假说**：熬过越多次垃圾收集的对象，越难死亡。

基于此，堆内存通常被划分为：

- **新生代 (Young Gen)**：对象生灭频繁，适合**复制算法 (Copying)**。
- **老年代 (Old Gen)**：对象存活率高，适合**标记-清除 (Mark-Sweep)** 或 **标记-整理 (Mark-Compact)**。

------

## 3. 历代 GC 收集器技术详解

### 3.1 第一阶段：单核极简时代 (Serial GC)

- **硬件背景**：单核 CPU，内存微小 (< 100MB)。
- **工作模式**：单线程串行回收，全过程 STW。
- **技术实现**：
  - 新生代：单线程复制。
  - 老年代：单线程标记-整理。
- **评价**：在现代 Docker 容器（< 1 Core）场景下仍有价值，无线程切换开销。

### 3.2 第二阶段：多核吞吐量时代 (Parallel GC)

- **JDK 8 默认**。
- **硬件背景**：多核 CPU 普及，内存中等 (1GB - 4GB)。
- **目标**：最大化 CPU 计算效率（吞吐量），适合后台批处理运算。
- **技术实现**：
  - Serial GC 的多线程版本。
  - **自适应策略**：`-XX:+UseAdaptiveSizePolicy` 自动调整 Eden/Survivor 比例。
- **缺陷**：内存越大，STW 停顿越长（几秒甚至更久）。

### 3.3 第三阶段：并发与低延迟时代 (CMS & G1)

随着 Web 应用普及，用户对响应时间（TP99）极其敏感。

#### A. CMS (Concurrent Mark Sweep)

- **特性**：第一款并发收集器，追求最短停顿。
- **技术实现**：
  1. **初始标记 (STW)**：仅标记 GC Roots。
  2. **并发标记**：用户线程与 GC 线程同时运行。
  3. **重新标记 (STW)**：修正并发期间变动的引用（使用**增量更新**算法）。
  4. **并发清除**：基于**标记-清除**算法。
- **致命缺陷**：无内存整理，产生**内存碎片**，最终导致 Full GC（回退到 Serial Old）。

#### B. G1 (Garbage-First) - *JDK 9+ 默认*

- **架构变革**：打破物理分代，引入 **Region**（区域）概念。
- **技术实现**：
  - 将堆划分为多个大小相等的 Region，每个 Region 动态充当 Eden/Survivor/Old。
  - **可预测停顿**：用户设定目标停顿时间（如 200ms），G1 计算收益，优先回收垃圾最多的 Region。
  - **算法**：局部是复制算法，整体是标记-整理。解决了 CMS 的碎片问题。
  - **SATB**：使用 Snapshot-At-The-Beginning 算法解决并发标记的一致性问题。

### 3.4 第四阶段：超大堆与极低延迟时代 (ZGC & Shenandoah)

- **硬件背景**：TB 级内存，64核+ CPU。
- **目标**：无论堆大小如何，停顿时间不超过 10ms（JDK 21+ 分代 ZGC < 1ms）。

#### ZGC (Z Garbage Collector)

- **核心技术**：
  1. **染色指针 (Colored Pointers)**：将对象状态（Marked, Remapped）存储在 64 位指针的高位中，而非对象头。
  2. **读屏障 (Load Barriers)**：应用线程读取对象引用时，JVM 拦截并检查指针颜色。如果指向旧地址，**自愈 (Self-healing)** 指针到新地址。
  3. **并发整理**：通过读屏障技术，实现了在移动对象的过程中，应用线程依然可以并发访问对象。

------

## 4. 关键技术对比分析

| **特性**       | **Parallel GC** | **CMS**           | **G1**                   | **ZGC**               |
| -------------- | --------------- | ----------------- | ------------------------ | --------------------- |
| **设计目标**   | 吞吐量优先      | 低延迟 (早期)     | 延迟可控 + 吞吐平衡      | 极致低延迟 (<1ms)     |
| **内存布局**   | 物理分代 (连续) | 物理分代 (连续)   | 逻辑分代 (Region)        | 逻辑分代 (Page)       |
| **老年代算法** | 标记-整理       | 标记-清除         | 标记-整理 (Region间复制) | 标记-整理 (并发)      |
| **STW 触发**   | 整个 GC 过程    | 初始/重新标记     | 初始/最终/筛选回收       | 仅根节点扫描          |
| **碎片化**     | 无              | **严重**          | 无                       | 无                    |
| **并发技术**   | 无              | 增量更新 + 写屏障 | SATB + 写屏障            | **染色指针 + 读屏障** |
| **适用堆大小** | < 4GB           | 2GB - 8GB         | 4GB - 64GB+              | 8GB - 16TB            |

------

## 5. 深度技术解析：并发难题的解决方案

在并发 GC 中，最大的挑战是：**GC 在分析对象图时，用户线程修改了引用关系**。这通常通过**三色标记法**配合**屏障技术**解决。

### 5.1 三色标记 (Tri-color Marking)

- **白色**：未访问（潜在垃圾）。
- **灰色**：已访问，但子引用未扫描完。
- **黑色**：已访问，子引用已扫描完（存活）。

**漏标问题**：黑色对象指向了白色对象，且灰色对象断开了对该白色对象的引用。若不处理，该白色对象会被误删。

### 5.2 解决方案对比

- **CMS (增量更新 - Incremental Update)**：
  - 关注引用的**插入**。
  - 逻辑：一旦黑色对象指向白色，将黑色变为灰色，稍后重扫。
  - 实现：**写屏障 (Write Barrier)**。
- **G1 (SATB - Snapshot At The Beginning)**：
  - 关注引用的**删除**。
  - 逻辑：在引用断开前，记录旧引用。GC 认为“开始时的快照”是活的，它就是活的。
  - 实现：**写屏障**。
- **ZGC (读屏障 - Load Barrier)**：
  - 逻辑：不关注引用何时变动。当用户线程**读取**指针时，检查指针颜色是否正确。如果不正确（对象被移动了），立刻修正指针地址。
  - 优势：彻底解耦了对象移动和应用访问的阻塞关系。

------

## 6. 总结与选型建议

硬件决定软件的上限。GC 的演进史就是将**“必须暂停世界的任务”**转化为**“可以并发执行的任务”**的过程。

- **遗留系统 (JDK 8, <4GB)**：保持默认 `Parallel GC`，吞吐量最高。
- **标准 Web 服务 (JDK 11/17, 4GB-32GB)**：使用 `G1 GC`，平衡延迟与吞吐，配置简单。
  - 参数：`-XX:+UseG1GC -XX:MaxGCPauseMillis=200`
- **核心低延迟服务/大内存 (JDK 17/21+, >32GB)**：强烈建议 `ZGC`。
  - 参数：`-XX:+UseZGC` (JDK 21+ 建议开启分代模式 `-XX:+ZGenerational`)

