---
title: Docker核心架构
date: 2025-12-18 19:52:05
tags: docker
---

这份文档总结了我们之前关于 Docker 核心架构的讨论，重点阐述了**镜像（只读层）**与**容器（读写层）**的关系，以及**联合文件系统（UnionFS）**的工作原理。

你可以将此文档作为团队内部的技术分享资料或个人复习笔记。

------

# Docker 核心架构技术文档：镜像、容器与分层存储

版本: 1.0

关键词: Docker, Image, Container, UnionFS, Layer, Copy-on-Write

## 1. 核心概念概览

Docker 的核心在于其独特的**分层存储架构**。与虚拟机（VM）不同，Docker 容器并不包含完整的操作系统内核，而是共享宿主机的内核，仅在文件系统层面进行了隔离。

- **镜像 (Image)**: 应用程序的静态打包，由一组**只读层**组成。
- **容器 (Container)**: 镜像的运行实例，本质上是**只读镜像层 + 一个可读写层**。

------

## 2. 镜像：只读层 (The Read-Only Layers)

镜像可以被理解为一个**“精简版的文件系统快照”**。

### 2.1 结构组成

镜像是分层构建的（Layered Build）。每一层都代表了 Dockerfile 中的一条指令（如 `FROM`, `RUN`, `COPY`）。

- **Base Layer (基础层)**: 通常是操作系统的用户空间（Rootfs），如 Ubuntu、Alpine。**注意：这里只包含 `/bin`, `/etc`, `/usr` 等文件，不包含 Linux 内核。**
- **Application Layers (应用层)**: 叠加在基础层之上的依赖库、代码文件、配置文件等。

### 2.2 特性

- **只读性 (Read-Only)**: 镜像构建完成后，其内部的所有层都是**不可变**的。这保证了环境的一致性——无论启动多少次，镜像本身永远不会被修改。
- **复用性**: 不同的镜像可以共享相同的基础层（例如，多个 Java 应用都可以共享同一个 JDK 基础镜像），从而节省磁盘空间。

------

## 3. 容器：读写层 (The Read-Write Layer)

当使用 `docker run` 启动容器时，Docker 并没有复制镜像文件，而是使用了**联合挂载**技术。

### 3.1 容器层的建立

容器 = **镜像层 (Base)** + **读写层 (Top Layer)**。

- Docker 在只读的镜像层顶部，添加了一个薄薄的**可读写层 (Read-Write Layer)**。
- 容器内产生的所有**数据修改、新文件写入、日志输出**，实际上都只发生在这一层。
- **生命周期**: 读写层是临时的。当容器被删除 (`docker rm`)，这一层及其中的数据会被彻底销毁（除非使用了 Volume 挂载）。

### 3.2 运行机制

容器本质上是一个**进程**。它运行在宿主机的内核上，但通过 Namespace (命名空间) 和 Cgroups (控制组) 技术，以为自己拥有独立的文件系统和资源。

------

## 4. 关键技术原理

Docker 如何实现“多个容器共享一个镜像且互不干扰”？

### 4.1 UnionFS (联合文件系统)

UnionFS 是一种分层、轻量级的文件系统，它支持将不同的目录挂载到同一个虚拟文件系统下。

- 它将所有的**只读镜像层**和顶部的**读写容器层**“压扁”成一个视图。
- 对用户来说，看到的是一个完整的文件系统，感觉不到层的存在。

### 4.2 Copy-on-Write (写时复制 CoW)

这是防止数据冲突、节省资源的核心机制。

- **读取文件 (Read)**: 容器需要读取文件时，会从最上层往下寻找。如果读写层没有，就读镜像层。
- **修改文件 (Write)**:
  1. 容器试图修改位于镜像层的文件（如 `/etc/nginx/nginx.conf`）。
  2. 由于镜像层是只读的，Docker 会先将该文件从镜像层**复制**到顶部的读写层。
  3. 容器对这个**副本**进行修改。
  4. 原始的镜像层文件依然存在，但被读写层的新版本“遮挡”了。

**结论**: 每个容器都有自己独立的读写层。容器 A 修改文件，只是在自己的读写层生成副本，完全不会影响容器 B 或底层的镜像。

------

## 5. 架构总结：OS vs Kernel

针对“小型操作系统”的理解修正：

| **特性**     | **虚拟机 (VM)**                 | **Docker 容器**                    |
| ------------ | ------------------------------- | ---------------------------------- |
| **基础建设** | 独立的硬件模拟 + 独立的完整内核 | **共享宿主机内核**                 |
| **镜像内容** | 庞大的完整 OS (GB 级)           | 仅包含用户空间文件 (Rootfs, MB 级) |
| **隔离级别** | 硬件级隔离 (彻底)               | 进程级隔离 (轻量)                  |
| **性能**     | 较重，有额外开销                | **原生性能** (几乎无损耗)          |

一句话总结:

各个容器确实是在同一个**基建（镜像文件 + 宿主机内核）**上运行。镜像提供了应用所需的“衣服”（环境依赖），而宿主机提供了“心脏”（内核驱动）。容器之间的隔离由读写层和 Linux Namespace 共同保证。

------

### 下一步建议

如果你需要深入验证这些概念，可以进行以下操作：

1. **验证共享内核**: 在宿主机和容器内分别执行 `uname -r`，看到的内核版本是一模一样的。
2. **验证 CoW 机制**: 使用 `docker inspect` 查看 GraphDriver 部分，观察 UpperDir (读写层) 和 LowerDir (镜像层) 的物理路径。
