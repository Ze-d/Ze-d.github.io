---
title: process,thread and coroutine
date: 2025-12-11 11:19:24
tags: [CS,OS]
---

> **进程 = 资源与地址空间的边界**
>  **线程 = CPU 能“直接感知”的执行单元**
>  **协程 = 在“线程内部”用软件做的小调度器**

------

## 1. 从硬件出发：CPU 眼里只有“当前那一串寄存器”

CPU 真正在乎的只有：

- **运算器**：包括寄存器和算数逻辑单元
- **PC（程序计数器）**：下一条要执行的指令地址
- **寄存器**：通用寄存器，标志寄存器，**指令寄存器**，段寄存器，控制寄存器，调试寄存器，描述符寄存器，任务寄存器，模型特定寄存器。
- **SP（栈指针）**：当前栈顶，用来管理函数调用栈

只要你把 **PC + 寄存器组 + 栈指针 + 程序状态字** 全部保存下来，换一套新的上来，CPU 就像“穿上了新号衣”，开始执行另一段程序——**这就是上下文切换（context switch）的本质**。

> 所以，从硬件角度看：
>  不管是“换进程”“换线程”，都是在换这“一堆寄存器 + 栈”的内容，只是涉及的东西多少有差别。

------

## 2. 进程：虚拟地址空间 + 一堆资源 + 至少一个执行流

### 1. 进程的定义（操作系统教科书版）

进程通常被定义为：

> **一个正在运行的程序及其所拥有的全部资源的集合**

包括：

- **独立的虚拟地址空间**
  - 代码段、数据段、堆、栈、共享库映射……
  - 由操作系统+MMU（内存管理单元）通过页表来实现
- **打开的文件、网络连接、设备等资源句柄**
- **进程控制块（PCB）**
  - 记录进程 ID、状态（就绪/运行/阻塞）、优先级、页表基址、账号信息、信号处理方式等

### 2. 在硬件/组成原理层面，进程带来的主要变化是什么？

**关键：切换进程时，除了寄存器，还要切页表（地址空间）**

- **MMU + 页表**：实现每个进程自己的“虚拟地址空间”
  - 不同进程看到的 0x40000000 这个虚拟地址，对应到物理内存可能完全不同
- **进程切换时**：
  - 保存当前 CPU 寄存器（PC、通用寄存器、SP…）到 PCB
  - **切换 CR3 / TTBR 之类的“页表基址寄存器”**，装上新进程的页表
  - 重新加载新进程的寄存器状态
  - 刷新 TLB（因为地址到物理页的映射变了）

所以：

> **进程上下文切换 = 寄存器上下文 + 地址空间上下文（页表） + 若干缓存/TLB 开销**
>  成本比较高，但换来的好处是：**强隔离**。

------

## 3. 线程：共享地址空间的多个“硬件视角的执行流”

### 1. 线程是什么？

线程可以理解为：

> **运行在同一进程地址空间内的多个“CPU 执行轨道”**

一个进程至少有一个线程（主线程），也可以有多个线程：

- 它们 **共享**：
  - 同一套代码段、全局变量、堆、打开的文件等
  - 也就是同一个虚拟地址空间、同一份资源
- 它们 **独享**：
  - 自己的 **栈**（局部变量、函数调用帧）
  - 自己的 **寄存器现场**（PC、通用寄存器、SP…）
  - 自己的调度信息（TCB：线程控制块）

换句话说：

> 线程是“轻量级的进程”，是 **进程内的执行单元**。

### 2. 在硬件/组成原理层面，线程切换有什么不同？

- 在线程切换时（同一进程内）：
  - CPU 只需要 **保存/恢复寄存器和栈指针**，**不需要切换页表**（虚拟地址空间没变）
  - 因此 **不需要（或少量）刷新 TLB**，Cache 命中率更高
- 所以：
  - **线程切换开销 < 进程切换开销**
  - 但两者对 CPU 来说本质都是“换一套寄存器 + 栈”的内核操作，只是换的多寡不同

------

## 4. 协程：在“一个线程里”软件实现的轻量级调度

### 1. 协程是啥？

协程（Coroutine）是**编程语言/库层面的概念**，通常**不由操作系统内核直接感知**。它的特点是：

- 运行在**某个线程内部**
- 多个协程 **共享这个线程的栈空间或拥有各自的用户态栈**（看具体实现）
- 调度由**语言运行时或用户代码控制**，不是操作系统
  - 协程之间是**协作式调度（cooperative）**：必须显式 `yield/await` 才让出执行权
  - 不像线程那样被内核“随时抢占”（preemptive）

典型例子：

- Python 的 `async/await`、`asyncio`
- Go 的 goroutine（本质是“用户态线程”+调度器）
- C++20 coroutine、Rust async

### 2. 协程在组成原理/硬件层面长啥样？

> 对 CPU 来说，协程根本“不是一个新东西”，仍然是**当前线程在跑指令**。

协程切换通常发生在 **用户态**：

- 只在用户态保存/恢复少量寄存器（PC、SP、部分 callee-saved 寄存器）
- 只在用户态改改“当前栈指针、当前协程控制块指针”
- 完全不产生系统调用（或者只在必要时，如 I/O）

和前两者对比：

- **进程切换**：内核态，换页表，刷新 TLB，寄存器一大堆
- **线程切换**：内核态，换寄存器和栈，地址空间不变
- **协程切换**：**用户态**，换一小部分寄存器 + 栈指针，不打扰 OS

所以：

> **协程切换开销 ≪ 线程切换开销 ≪ 进程切换开销**

这就是为什么协程特别适合**高并发 I/O 型程序**（比如服务端、爬虫）。

------

## 5. 三者之间的“套娃关系”

可以画成这样一个层次结构（逻辑上）：

- **一台机器**：多个 CPU 核心（core）
  - **操作系统**：调度多个进程（process）
    - 每个进程：包含多个线程（thread）
      - 每个线程：可以再由语言运行时调度多个协程（coroutine）

组合举例：

- `N` 个进程 × 每个进程 `M` 个线程 × 每个线程 `K` 个协程
   → 总共 `N × M × K` 个逻辑“并发执行单元”

**注意：**

- 真正并行跑起来的数量取决于 **CPU 核心数** 和 **内核调度的线程数**；
- 协程只是把一个线程内部的时间片切得更细，把等待 I/O 的时间利用起来。

------

## 6. 联系和区别总结（表格版）

### 1. 谁来调度？

| 对象 | 调度者              | 是否内核可见 | 是否可被时钟中断抢占 |
| ---- | ------------------- | ------------ | -------------------- |
| 进程 | 操作系统内核        | 是           | 是（内核调度算法）   |
| 线程 | 操作系统内核        | 是           | 是（内核调度算法）   |
| 协程 | 用户态运行时 / 程序 | 否（通常）   | 一般**否**（协作式） |

### 2. 资源隔离/共享

| 对象       | 地址空间                    | 全局变量/堆 | 打开的文件 | 栈与寄存器                                       |
| ---------- | --------------------------- | ----------- | ---------- | ------------------------------------------------ |
| 进程       | 独立                        | 独立        | 大多独立   | 每进程内的线程各自有                             |
| 同进程线程 | 共享同一进程地址空间        | 共享        | 共享       | **每线程独立栈 + 寄存器**                        |
| 协程       | 继承所属线程/进程的地址空间 | 共享        | 共享       | **每协程逻辑上有自己的栈帧（实现方式依赖语言）** |

### 3. 上下文切换开销（从组成原理角度）

| 对象 | 切换需要做什么                                      | 大致成本等级 |
| ---- | --------------------------------------------------- | ------------ |
| 进程 | 保存/恢复寄存器 + 切换页表 + TLB 影响 + OS 调度开销 | 最大         |
| 线程 | 保存/恢复寄存器 + 切栈 + OS 调度开销                | 中           |
| 协程 | 用户态保存/恢复少量寄存器 + 栈指针，几乎无内核参与  | 最小         |

------

## 7. 结合计算机组成原理再串一下核心逻辑

1. **流水线/指令周期角度**
   - 不管执行谁的代码，本质都是：取指 → 译码 → 执行 → 访存 → 写回
   - 进程/线程/协程只是 **换了一套“寄存器上下文 + 内存视图”再继续跑指令**
2. **MMU 和虚拟内存角度**
   - 进程：不同的页表，虚拟地址到物理地址的映射不同 → 实现逻辑隔离
   - 线程/协程：共享页表 → 看见同一块虚拟地址空间
3. **中断与陷入角度**
   - 进程/线程切换：通常由时钟中断、I/O 中断引发，CPU 进入内核态，执行调度器
   - 协程切换：大多不依赖硬件中断，而是程序在用户态主动 `yield/await`，控制权交给协程调度器
4. **多核与并行**
   - 进程和线程都可以被调度到不同的 CPU 核心上 → 真正“同时”执行
   - 单个线程内的协程本质是“伪并行”（时间片分片），要多线程 + 多核才有物理并行

------

## 8. 各自更适合干什么？

- **进程**：
  - 需要**强隔离、安全性**的场景：浏览器标签页、不同服务、不同用户程序
  - 直接配合多核实现粗粒度并行
- **线程**：
  - 需要在同一地址空间内**共享大量数据**、同时利用多核的场景
  - 比如：并行计算、web 服务器中的工作线程池
- **协程**：
  - 极高并发、主要等待 I/O 的场景：网络服务、爬虫、消息处理
  - 典型就是“**用极少的线程承载大量协程**”：减少内核调度负担，降低上下文切换成本

------

如果你愿意下一步可以一起做两件事：

1. 画一张“从 CPU 寄存器 → 进程 → 线程 → 协程”的示意图，用于记忆/做 PPT。
2. 结合你常用的语言（比如 Java、C++、Python）具体看一看：它们分别怎么在运行时把“协程/线程”映射到 OS 线程上的。

## 9.从 CPU 寄存器 → 进程 → 线程 → 协程 的示意图

你可以直接把下面这两张放进 PPT（改改字号/颜色就行）。

### 1. 分层结构图（自下而上）

```text
┌───────────────────────────────────────────────┐
│                 硬件 / CPU                   │
│  • 通用寄存器、PC、SP、FLAGS                 │
│  • MMU + TLB（做虚拟地址 → 物理地址映射）    │
└───────────────────────▲───────────────────────┘
                        │
                        │   页表基址寄存器 CR3/TTBR
┌───────────────────────┴───────────────────────┐
│                进程 Process（OS）            │
│  • 虚拟地址空间（代码段/数据段/堆/栈）       │
│  • 打开的文件、socket 等资源                 │
│  • 进程控制块 PCB：页表指针、权限、状态等     │
└───────────────────────▲───────────────────────┘
                        │
                        │   OS 调度器：时钟中断、就绪队列
┌───────────────────────┴───────────────────────┐
│              线程 Thread（OS 级）            │
│  • 共享所属进程的虚拟地址空间与资源          │
│  • 独立的寄存器现场（PC, SP, 寄存器组）      │
│  • 独立的线程栈                              │
│  • 线程控制块 TCB                             │
└───────────────────────▲───────────────────────┘
                        │
                        │   语言运行时 / 用户态调度器
┌───────────────────────┴───────────────────────┐
│           协程 Coroutine（语言级）           │
│  • 运行在某个线程内部                         │
│  • 用户态保存少量寄存器 + 栈指针即可切换      │
│  • 由语言运行时/库协作式调度（yield/await）   │
└───────────────────────────────────────────────┘
```

你也可以用“多对多”的感觉突出并发关系：

```text
      ┌───────────── 协程 coro1, coro2, ... ─────────────┐
      │   (语言运行时在用户态做小调度)                   │
      └───────────────▲───────────────▲──────────────────┘
                      │               │
       OS线程 T1  ────┘        OS线程 T2  ──── (…)
           ▲                         ▲
           │ 内核调度                │
      ┌────┴─────────────────────────┴─────┐
      │         进程 P：虚拟地址空间        │
      └──────────────▲─────────────────────┘
                     │ 页表
      ┌──────────────┴─────────────────────┐
      │         CPU 寄存器 + MMU           │
      └────────────────────────────────────┘
```

在 PPT 里你可以：

- 最下层写：**“CPU 寄存器 = 真正被硬件执行的上下文”**
- 中间两层写：**“进程 = 地址空间边界”“线程 = CPU 直接感知的执行单元”**
- 最上层写：**“协程 = 线程内部的软件调度单元（OS 不直接看到）”**

------

## 10.Java / C++ / Python：线程/协程是怎么映射到 OS 线程的？

先给一个总图，方便记忆：

- **OS 线程 ↔ 硬件核**：由内核调度
- **语言线程 ↔ OS 线程？** 看实现
- **协程 ↔ 用户态结构**：由运行时/库自己调度

------

### 1. Java：从“1:1 线程”到 Loom 虚拟线程

#### 1）传统 Java 线程（`java.lang.Thread`）

- **映射关系**：
  - 现代 HotSpot / OpenJDK：**1 个 Java Thread = 1 个 OS 线程**（1:1 模型）
- 底层实现：
  - JVM 调用平台 API：Linux 上是 `pthread_create`，Windows 上是 `CreateThread` 等
  - OS 负责把这些线程调度到 CPU 核心上运行
- 特点：
  - 上下文切换成本 = 内核线程切换成本（需要内核参与）
  - 真正可以多核并行

> 在前面的示意图里：`java.lang.Thread` 就直接对应“**线程 Thread（OS 级）**”那一层。

#### 2）Java 协程 / 虚拟线程（Project Loom, JDK 19+ / 21+）

JDK 21 里引入了 **虚拟线程（Virtual Thread）**：

- **平台线程（Platform Thread）**：
  - 就是传统 `new Thread()` 出来的，**1:1 映射到 OS 线程**
- **虚拟线程（Virtual Thread）**：
  - 用 `Thread.ofVirtual()` 创建的
  - 是一种 **JVM 级的“协程/用户态线程”**
  - **很多虚拟线程 M → 少量 OS 线程 N（carrier threads）**

工作机制（简化版）：

1. 你开了 10 万个虚拟线程，它们都在 JVM 里排队。
2. JVM 准备一个 OS 线程池（carrier threads），比如 8 个。
3. 某个虚拟线程要执行时：
   - JVM 把它“挂”到一个 carrier OS 线程上，恢复它的寄存器/栈（在用户态描述）
   - OS 看起来只是这个 carrier 线程在跑而已
4. 如果虚拟线程遇到**阻塞 I/O**：
   - Loom 友好的 I/O 会在底层转为“非阻塞 + 事件回调”，
   - JVM 把当前虚拟线程 park 掉，从 carrier OS 线程上摘下来，
   - carrier OS 线程则可以去执行其他虚拟线程。

**对应我们的图：**

- OS 只看到 **少量平台线程（carrier 线程）**
- 在这些线程内部，JVM 再自己做一层“协程式调度”（虚拟线程）

所以 Java 现在：

- **线程（平台线程）**：1:1 映射到 OS 线程
- **虚拟线程**：在 JVM 内部用用户态调度器 M:N 映射到平台线程（→ OS 线程）

------

### 2. C++：标准线程 = OS 线程，协程完全由库自己玩

#### 1）`std::thread` 与 OS 线程

- C++11 引入 `std::thread`：
  - 几乎所有主流实现（libstdc++, MSVC, libc++）都是：
     **1 个 `std::thread` = 1 个 OS 线程**
  - 底层用 pthread / Win32 thread 等实现

所以在你的那张图里：

- `std::thread` 就是“线程 Thread（OS 级）”那层，一路被 OS 调度到 CPU 上。

#### 2）C++20 协程（`co_await` 等）

C++20 的协程是 **编译器语法改写机制**：

- `co_await` / `co_yield` / `co_return` 会把函数变成一个状态机
- 标准 **不规定调度策略**，只规定“怎么被改写成状态机、怎么 resume/suspend”
- 具体调度要靠库：
  - 比如游戏引擎、网络库（如 folly、asio 扩展）会自己写一个“协程调度器”
  - 这些协程通常：
    - **运行在某个 `std::thread` 上的事件循环里**
    - 或者分布到一个线程池（多个 OS 线程）上

**映射关系：**

- OS 只看到若干个 `std::thread`（OS 线程）
- 在每个 `std::thread` 里，库自己调度大量 C++ 协程（完全在用户态）

也就是说：

> C++ 这边，**线程 = OS 线程**；
>  **协程 = 完全用户态结构，怎么映射到线程由你自己/库决定**。

------

### 3. Python：线程 1:1 + GIL 限制；`asyncio` 协程在单线程事件循环上

#### 1）`threading.Thread` 与 OS 线程

在 CPython 中：

- `threading.Thread` 基本就是：**1 个 Python 线程对象 = 1 个 OS 线程**（pthread / Win32）
- 但是有个关键问题：**GIL（全局解释器锁）**：
  - 同一个进程中，同一时刻只有一个线程在执行 Python 字节码
  - 所以多线程对 **I/O 密集** 有用（可以让阻塞 I/O 期间其他线程跑）
  - 对 **CPU 密集** 不会利用多核（除非开多进程）

从我们的图来看：

- OS 看到很多线程，但在 CPython 解释器这一层上，又用 GIL 做了“序列化阀门”。

#### 2）`asyncio` / `async def` 协程

Python 3 的协程是 **语言级协程**：

- `async def` 定义协程函数，`await` 作为“主动让出执行权”的点
- `asyncio` 事件循环（event loop）：
  - 通常运行在 **一个 OS 线程里**（默认主线程）
  - 自己维护任务队列、定时器、I/O 就绪事件
  - 在用户态调度所有协程（任务）

**映射关系：**

- 一个 event loop 通常 = 一个 OS 线程 + 一个 `asyncio` 线程内调度器
- 成千上万的 `async def` 协程任务全部跑在这个 OS 线程上，**协作式调度**：
  - 协程在 `await` 可等待对象时挂起，让 event loop 切到别的协程

如果你开多个进程或多个 event loop 线程，则：

- 多个进程 ↔ 多个地址空间 + 多个 GIL
- 每个进程中，又可以有自己的 OS 线程 + event loop
- 每个 event loop 内又有很多协程

所以 Python 典型模型是：

> **进程级并行（多进程，用多核） + 进程内用协程做高并发 I/O**
>  线程更多是“辅助角色”（配合一些底层库释放 GIL）。

------

## 11.帮你打个总的记忆点

你可以在 PPT 上用这几句做总结：

1. **从硬件看**：
    CPU 只认“当前那一套寄存器 + 栈”，进程/线程/协程只是不同层次的“换这套东西”的方式。
2. **进程**：
   - OS 提供的 **地址空间与资源边界**，进程切换 = 寄存器 + 页表 + TLB。
   - 强隔离，开销最大。
3. **线程**：
   - OS 直接感知的 **执行单元**，共享进程地址空间。
   - 切换只换寄存器 + 栈，不换页表，开销中等。
4. **协程**：
   - 语言/库在 **线程内部做的小调度**，只在用户态保存少量上下文。
   - OS 不知道它们，开销最小。
5. **Java / C++ / Python 映射一句话版**：
   - **Java**：`Thread` ≈ OS 线程；Loom 虚拟线程 = JVM 内协程，多虚拟线程映射到少量 OS 线程。
   - **C++**：`std::thread` ≈ OS 线程；C++20 协程完全由库在用户态调度。
   - **Python**：`threading.Thread` ≈ OS 线程 + GIL 限制；`asyncio` 协程跑在单 OS 线程的事件循环上。

## 12.附录：名词解析

**虚拟地址**

