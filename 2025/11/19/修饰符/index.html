<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>修饰符 | Hexo</title><meta name="author" content="Zed"><meta name="copyright" content="Zed"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="所谓“修饰符”，本质上是在“声明（declaration）上挂元数据”，告诉编译器&#x2F;运行时：这个东西应该如何被  看见（可见性 &#x2F; 访问控制） 存放（存储位置 &#x2F; 生命周期 &#x2F; 对齐方式） 使用（能不能改、能不能被覆盖、是否线程安全等等） 连接（如何跟别的语言&#x2F;库&#x2F;OS 交互）  下面按你问的几个维度，把 Java 和 C++ 的修饰符">
<meta property="og:type" content="article">
<meta property="og:title" content="修饰符">
<meta property="og:url" content="http://example.com/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="所谓“修饰符”，本质上是在“声明（declaration）上挂元数据”，告诉编译器&#x2F;运行时：这个东西应该如何被  看见（可见性 &#x2F; 访问控制） 存放（存储位置 &#x2F; 生命周期 &#x2F; 对齐方式） 使用（能不能改、能不能被覆盖、是否线程安全等等） 连接（如何跟别的语言&#x2F;库&#x2F;OS 交互）  下面按你问的几个维度，把 Java 和 C++ 的修饰符">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/asuka.jpg">
<meta property="article:published_time" content="2025-11-19T11:53:53.000Z">
<meta property="article:modified_time" content="2025-11-19T12:18:27.645Z">
<meta property="article:author" content="Zed">
<meta property="article:tag" content="java cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/asuka.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "修饰符",
  "url": "http://example.com/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/",
  "image": "http://example.com/img/asuka.jpg",
  "datePublished": "2025-11-19T11:53:53.000Z",
  "dateModified": "2025-11-19T12:18:27.645Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zed",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '修饰符',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bkground.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/bkground.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">修饰符</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-images"></i><span> Picture</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">修饰符</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-11-19T11:53:53.000Z" title="Created 2025-11-19 19:53:53">2025-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-19T12:18:27.645Z" title="Updated 2025-11-19 20:18:27">2025-11-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p> <strong>所谓“修饰符”，本质上是在“声明（declaration）上挂元数据”，告诉编译器&#x2F;运行时：这个东西应该如何被</strong></p>
<ul>
<li>看见（可见性 &#x2F; 访问控制）</li>
<li>存放（存储位置 &#x2F; 生命周期 &#x2F; 对齐方式）</li>
<li>使用（能不能改、能不能被覆盖、是否线程安全等等）</li>
<li>连接（如何跟别的语言&#x2F;库&#x2F;OS 交互）</li>
</ul>
<p>下面按你问的几个维度，把 Java 和 C++ 的修饰符拆开说。</p>
<hr>
<h2 id="一、从整体上看修饰符：几个维度"><a href="#一、从整体上看修饰符：几个维度" class="headerlink" title="一、从整体上看修饰符：几个维度"></a>一、从整体上看修饰符：几个维度</h2><p>可以先把修饰符按“背后影响的系统层级”分一下类（Java &#x2F; C++ 都适用）：</p>
<ol>
<li><strong>只影响编译器的静态检查 &#x2F; 类型系统</strong><ul>
<li>比如：<code>public/private/protected</code>、<code>abstract</code>、<code>override</code>、<code>final</code>（对方法&#x2F;类）等。</li>
<li>主要作用：<strong>限制&#x2F;描述用法</strong>，帮助编译器在编译时报错，或者做某些优化。</li>
<li>OS 完全不知道这些东西存在。</li>
</ul>
</li>
<li><strong>影响内存布局 &#x2F; 生命周期 &#x2F; 可变性（memory-related）</strong><ul>
<li>C++：<code>static</code>, <code>thread_local</code>, <code>const</code>, <code>volatile</code>, <code>mutable</code>, <code>alignas</code>…</li>
<li>Java：<code>static</code>, <code>final</code>（字段&#x2F;变量）, <code>volatile</code>, <code>transient</code>…</li>
<li>这些会决定对象&#x2F;变量 <strong>在哪个内存区域、活多久、能否被修改、访问是否需要屏障&#x2F;栅栏</strong>。</li>
</ul>
</li>
<li><strong>影响并发与内存模型</strong><ul>
<li>C++：<code>volatile</code>（旧时代用于内存映射 IO，现在并发更多靠 <code>std::atomic</code>）、<code>thread_local</code>、<code>noexcept</code> 影响异常路径。</li>
<li>Java：<code>volatile</code>, <code>synchronized</code>。</li>
<li>编译器会据此插入锁、fence、内存屏障指令，从而<strong>约束 CPU 的指令&#x2F;内存重排</strong>，保证多线程可见性。</li>
</ul>
</li>
<li><strong>影响链接和 ABI（跟 OS&#x2F;其他语言交互）</strong><ul>
<li>C++：<code>extern</code>, <code>static</code>（在命名空间&#x2F;全局作用域上做“内部链接”）、<code>extern &quot;C&quot;</code>、平台相关的 <code>__declspec(dllexport)</code>、<code>__attribute__((visibility))</code>。</li>
<li>Java：<code>native</code>。</li>
<li>这些决定了：<strong>符号名如何出现在目标文件中、是否导出到动态库、调用约定如何</strong>，这才是最接近“控制操作系统”的部分（通过控制与 OS loader &#x2F; C 库的接口）。</li>
</ul>
</li>
<li><strong>仅影响优化 &#x2F; 提示（属于“控制编译器行为”的软约束）</strong><ul>
<li>C&#x2F;C++：<code>inline</code>, 历史上的 <code>register</code>，<code>[[likely]]</code>&#x2F;<code>[[unlikely]]</code> 等 attribute。</li>
<li>Java：几乎没有显式“优化修饰符”，更多是由 JIT 自动决定，<code>final</code>&#x2F;<code>private</code> 帮助 JIT 优化。</li>
</ul>
</li>
</ol>
<p>下面分 Java &#x2F; C++ 具体展开。</p>
<hr>
<h2 id="二、Java-中的修饰符：谁管内存？谁管并发？谁管-OS？"><a href="#二、Java-中的修饰符：谁管内存？谁管并发？谁管-OS？" class="headerlink" title="二、Java 中的修饰符：谁管内存？谁管并发？谁管 OS？"></a>二、Java 中的修饰符：谁管内存？谁管并发？谁管 OS？</h2><h3 id="1-访问控制修饰符：public-protected-private-包可见"><a href="#1-访问控制修饰符：public-protected-private-包可见" class="headerlink" title="1. 访问控制修饰符：public &#x2F; protected &#x2F; private &#x2F; 包可见"></a>1. 访问控制修饰符：<code>public</code> &#x2F; <code>protected</code> &#x2F; <code>private</code> &#x2F; 包可见</h3><p><strong>影响：只控制“谁能访问”，属于“编译器 + JVM 验证”领域，不直接影响内存&#x2F;OS。</strong></p>
<ul>
<li>**编译期：**编译器根据访问位置检查是否合法；非法直接编译错误。</li>
<li>**运行期：**JVM class loader 验证时也会检查（防止手工构造字节码作弊）。</li>
<li><strong>设计原理：</strong><ul>
<li>支持封装（encapsulation）、信息隐藏，保证类的内部状态不被随意破坏。</li>
<li>把“模块边界”编码进类型系统，而不靠文档约定。</li>
</ul>
</li>
</ul>
<h3 id="2-static：类级别成员-静态初始化"><a href="#2-static：类级别成员-静态初始化" class="headerlink" title="2. static：类级别成员 &#x2F; 静态初始化"></a>2. <code>static</code>：类级别成员 &#x2F; 静态初始化</h3><p><strong>影响内存 + 生命周期，也影响类加载顺序。</strong></p>
<ul>
<li>对字段：<ul>
<li>非 <code>static</code>：每个对象一份，存在堆上的对象里。</li>
<li><code>static</code>：<strong>每个类一份</strong>，通常存在 JVM 的”元空间 + 静态区域”中，由 class loader 管理，随 Class 的生命周期（通常接近整个进程）。</li>
</ul>
</li>
<li>对方法：<ul>
<li>相当于“没有隐含的 <code>this</code> 参数”的普通函数，只是语法上挂在类名下。</li>
</ul>
</li>
<li>设计原理：<ul>
<li>把“与具体实例无关、属于整个类&#x2F;类型的信息”单独抽出来共享，减少内存和耦合。</li>
<li>JVM 在类加载时一次性为 static 字段分配 &amp; 初始化，有固定的生命周期，方便实现常量池、单例等模式。</li>
</ul>
</li>
</ul>
<h3 id="3-final：一次性赋值-不可继承-不可覆盖"><a href="#3-final：一次性赋值-不可继承-不可覆盖" class="headerlink" title="3. final：一次性赋值 &#x2F; 不可继承 &#x2F; 不可覆盖"></a>3. <code>final</code>：一次性赋值 &#x2F; 不可继承 &#x2F; 不可覆盖</h3><p><strong>主要是编译期约束，但也有内存模型层面的意义。</strong></p>
<ul>
<li>对变量&#x2F;字段：<ul>
<li>“只允许赋值一次”，可以是声明时赋值，也可以在构造函数里赋值一次。</li>
<li>对编译器：可以认为这些值不会被修改，从而可以做常量折叠、内联等优化。</li>
<li>对 Java 内存模型：<code>final</code> 字段在构造完成后对其他线程有更好的可见性保证（JMM 里专门有 <code>final</code> 的规则）。</li>
</ul>
</li>
<li>对方法：<code>final</code> 方法不能被子类 override，JIT 更容易内联。</li>
<li>对类：<code>final</code> 类不能被继承（例如 <code>String</code>），防止继承破坏不变式，增加安全性。</li>
<li>大方向设计：<ul>
<li><strong>表达“不可变意图（immutability intent）”</strong> -&gt; 提高并发安全性 + 优化空间。</li>
</ul>
</li>
</ul>
<h3 id="4-volatile：可见性-禁止重排"><a href="#4-volatile：可见性-禁止重排" class="headerlink" title="4. volatile：可见性 + 禁止重排"></a>4. <code>volatile</code>：可见性 + 禁止重排</h3><p><strong>典型的“控制内存模型 + 间接控制 CPU 指令”的修饰符。</strong></p>
<ul>
<li>告诉 JVM&#x2F;编译器：<ul>
<li>对这个字段的读写不能被缓存到寄存器或线程私有缓存里，要直接从共享内存读&#x2F;写。</li>
<li>在它前后的内存访问不能随意被重排序。</li>
</ul>
</li>
<li>JVM 编译成机器码时，会插入相应的 <strong>内存屏障 (memory fence)</strong> 指令或使用特定的 load&#x2F;store 语义，最终约束 CPU 的乱序执行。</li>
<li>设计原理：<ul>
<li>为了对多线程可见性给出<strong>语言级别的保证</strong>，而不是直接暴露 CPU 的 cache&#x2F;指令序问题。</li>
<li>一种“弱版的原子性 + 强版的可见性”工具；复杂并发现在更多用 <code>java.util.concurrent</code> 原子类和锁。</li>
</ul>
</li>
</ul>
<h3 id="5-synchronized：互斥锁-happens-before"><a href="#5-synchronized：互斥锁-happens-before" class="headerlink" title="5. synchronized：互斥锁 + happens-before"></a>5. <code>synchronized</code>：互斥锁 + happens-before</h3><p><strong>控制并发行为，JVM 会生成 monitorenter&#x2F;monitorexit 指令，间接调用 OS 的锁原语。</strong></p>
<ul>
<li>方法上 <code>synchronized</code>：等价于对 <code>this</code> 或对应 <code>Class</code> 对象加锁。</li>
<li>块上 <code>synchronized(obj)</code>：对 <code>obj</code> 对应的监视器加锁。</li>
<li>JVM 实现：<ul>
<li>字节码中是 <code>monitorenter</code> &#x2F; <code>monitorexit</code>，JVM 里会实现偏向锁、轻量级锁、自旋锁等。</li>
<li>当竞争激烈时，JVM 可能退化到操作系统的互斥原语（mutex&#x2F;futex 等）。</li>
</ul>
</li>
<li>设计原理：<ul>
<li>以 <strong>对象作为互斥的基本单元</strong>，简化同步语义。</li>
<li>在 Java 内存模型中，<code>synchronized</code> 还自带 happens-before 关系，保证临界区内写入对解锁后获取锁的其他线程可见。</li>
</ul>
</li>
</ul>
<h3 id="6-transient：影响序列化（对象持久化的“内存视图”）"><a href="#6-transient：影响序列化（对象持久化的“内存视图”）" class="headerlink" title="6. transient：影响序列化（对象持久化的“内存视图”）"></a>6. <code>transient</code>：影响序列化（对象持久化的“内存视图”）</h3><ul>
<li>告诉序列化框架（如 <code>ObjectOutputStream</code>）：这个字段<strong>不要写入持久化流</strong>。</li>
<li>对内存中的对象本身没有影响；影响的是 <strong>“对象如何被持久化&#x2F;跨 JVM 传输”</strong>。</li>
<li>设计原理：<ul>
<li>区分“对象的运行时状态”和“需要持久保存的逻辑状态”，避免把临时缓存、锁、线程池之类乱序列化。</li>
</ul>
</li>
</ul>
<h3 id="7-abstract-native-strictfp-等"><a href="#7-abstract-native-strictfp-等" class="headerlink" title="7. abstract &#x2F; native &#x2F; strictfp 等"></a>7. <code>abstract</code> &#x2F; <code>native</code> &#x2F; <code>strictfp</code> 等</h3><ul>
<li><code>abstract</code>：只影响编译器（方法没有实现 &#x2F; 类不能实例化），跟内存无直接关系。</li>
<li><code>native</code>：告诉 JVM 这个方法的实现是 C&#x2F;C++ 等 native 代码，JVM 在调用时走 JNI -&gt; OS 动态库加载。<ul>
<li>这是 Java 修饰符里最<strong>直接联系 OS</strong> 的一个：它不直接控制 OS，但告诉 JVM 去跟 OS 的动态库和 C ABI 接口。</li>
</ul>
</li>
<li><code>strictfp</code>：控制浮点运算严格遵守 IEEE 754 的精度&#x2F;舍入行为，不随硬件扩展精度而变；影响编译器如何生成浮点指令。</li>
</ul>
<hr>
<h2 id="三、C-中的修饰符：更贴近硬件-OS"><a href="#三、C-中的修饰符：更贴近硬件-OS" class="headerlink" title="三、C++ 中的修饰符：更贴近硬件 &amp; OS"></a>三、C++ 中的修饰符：更贴近硬件 &amp; OS</h2><p>C++ 修饰符种类非常多，可以按“存储&#x2F;生命周期”、“类型限定”、“函数行为”、“链接&#x2F;ABI”几类来看。</p>
<h3 id="1-存储类修饰符：static-extern-thread-local-（历史上的-register）"><a href="#1-存储类修饰符：static-extern-thread-local-（历史上的-register）" class="headerlink" title="1. 存储类修饰符：static, extern, thread_local, （历史上的 register）"></a>1. 存储类修饰符：<code>static</code>, <code>extern</code>, <code>thread_local</code>, （历史上的 <code>register</code>）</h3><h4 id="static（在-C-C-里含义比-Java-多）"><a href="#static（在-C-C-里含义比-Java-多）" class="headerlink" title="static（在 C&#x2F;C++ 里含义比 Java 多）"></a><code>static</code>（在 C&#x2F;C++ 里含义比 Java 多）</h4><ul>
<li><strong>在全局&#x2F;命名空间作用域：</strong><ul>
<li><code>static int x;</code> -&gt; 具有内部链接（只在当前翻译单元可见），存在静态存储区（.data &#x2F; .bss 段）。</li>
<li>OS loader 会把这些变量所在的段映射到进程地址空间中。</li>
</ul>
</li>
<li><strong>在函数体内：</strong><ul>
<li><code>static int x = 0;</code> -&gt; 函数局部“静态变量”，只初始化一次，生命周期贯穿整个程序。</li>
</ul>
</li>
<li>设计原理：<ul>
<li>区分“<strong>作用域</strong>”（在哪里能看见）和“<strong>存储期</strong>”（活多久），允许有局部的“全局状态”。</li>
</ul>
</li>
</ul>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a><code>extern</code></h4><ul>
<li>声明某个符号在别的翻译单元定义，用于链接阶段把它们“拼起来”。</li>
<li>例如在头文件里 <code>extern int global_counter;</code>，在某个 .cpp 里 <code>int global_counter = 0;</code>。</li>
<li>设计原理：<ul>
<li>支持多文件编译与链接，把“声明”和“定义”分离。</li>
</ul>
</li>
</ul>
<h4 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a><code>thread_local</code></h4><ul>
<li>指定变量为<strong>线程局部存储（TLS）</strong>，每个线程有独立的一份。</li>
<li>编译器会把它放到特定的 TLS 段，OS 在创建线程时复制&#x2F;初始化相关结构。</li>
<li>设计原理：<ul>
<li>提供简单的 per-thread 状态，而不需要显式 map&lt;thread_id, …&gt;；也是直接对接 OS 的一个点。</li>
</ul>
</li>
</ul>
<h4 id="register（历史遗迹）"><a href="#register（历史遗迹）" class="headerlink" title="register（历史遗迹）"></a><code>register</code>（历史遗迹）</h4><ul>
<li>早期 C 时代用于“建议编译器把变量放入寄存器”，现代编译器基本忽略，或者只用来禁止对该变量取地址。</li>
<li>典型例子：<strong>修饰符曾经是“优化 hint”，随着编译器变聪明，语义越来越弱。</strong></li>
</ul>
<h3 id="2-类型限定符：const-volatile-mutable"><a href="#2-类型限定符：const-volatile-mutable" class="headerlink" title="2. 类型限定符：const, volatile, mutable"></a>2. 类型限定符：<code>const</code>, <code>volatile</code>, <code>mutable</code></h3><h4 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h4><ul>
<li>告诉编译器：<strong>通过该名字不能修改对象</strong>。</li>
<li>对编译器：<ul>
<li>可以进行更激进的优化（假定值不会变、允许放在只读段）。</li>
</ul>
</li>
<li>对内存：<ul>
<li>一些实现会把 <code>const</code> 全局对象放入只读数据段（被 OS 以只读方式映射），写入会触发段错误。</li>
</ul>
</li>
<li>设计原理：<ul>
<li>把“不变性”编码到类型系统，提高安全性（接口承诺）+ 优化空间。</li>
</ul>
</li>
</ul>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h4><ul>
<li>告诉编译器：这个内存位置<strong>可能被外部机制改变</strong>（硬件寄存器、中断、DMA 等），不要优化掉访问，也不要对它做不当重排&#x2F;缓存。</li>
<li>原始设计主要是为 <strong>内存映射 I&#x2F;O</strong> 服务，而非多线程同步（现代并发更多用 <code>std::atomic</code>）。</li>
<li>设计原理：<ul>
<li>显式暴露“这个位置是特殊的，不是普通 RAM”，语言层面禁止某些优化，从而正确驱动外设。</li>
</ul>
</li>
</ul>
<h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a><code>mutable</code></h4><ul>
<li>仅用于类成员：允许在 <code>const</code> 成员函数中修改这个字段（绕过 <code>const</code> 限制）。</li>
<li>设计原理：<ul>
<li>支持“逻辑上不变，但实现上需要缓存”的场景（例如懒加载缓存）。</li>
</ul>
</li>
</ul>
<h3 id="3-函数-类相关修饰符：inline-virtual-explicit-constexpr-override-final-noexcept…"><a href="#3-函数-类相关修饰符：inline-virtual-explicit-constexpr-override-final-noexcept…" class="headerlink" title="3. 函数&#x2F;类相关修饰符：inline, virtual, explicit, constexpr, override, final, noexcept…"></a>3. 函数&#x2F;类相关修饰符：<code>inline</code>, <code>virtual</code>, <code>explicit</code>, <code>constexpr</code>, <code>override</code>, <code>final</code>, <code>noexcept</code>…</h3><p>这些大部分是“控制编译器行为 + 运行时调度方式”的。</p>
<ul>
<li><strong><code>inline</code></strong>：建议（早期）或允许（现代）编译器把函数体直接嵌入调用点；也有“允许多重定义但 ODR 合一”的链接语义。</li>
<li><strong><code>virtual</code></strong>：<ul>
<li>要求该函数使用虚函数表（vtable）进行动态多态调用。</li>
<li>编译器为每个含虚函数的类生成 vptr + vtable，放在数据段里，间接影响对象内存布局。</li>
</ul>
</li>
<li><strong><code>explicit</code></strong>：限制构造函数&#x2F;转换函数参与隐式转换，只影响编译器的重载解析。</li>
<li><strong><code>constexpr</code> &#x2F; <code>consteval</code></strong>：<ul>
<li>要求或允许在编译期求值。编译器会在编译阶段执行一段“解释器级别”的 C++，把结果当常量折叠进二进制。</li>
</ul>
</li>
<li><strong><code>override</code> &#x2F; <code>final</code></strong>（在 C++11 以后是“函数&#x2F;类说明符”而不是关键字，但作用类似）：<ul>
<li>纯粹是编译期检查：<code>override</code> 确保你真在覆写一个虚函数；<code>final</code> 禁止别的类继续继承或覆写。</li>
</ul>
</li>
<li><strong><code>noexcept</code></strong>：<ul>
<li>告诉编译器这个函数不会抛异常，异常表&#x2F;栈展开信息可以省略，有助于优化调用栈和 ABI。</li>
<li>如果实际抛异常，通常调用 <code>std::terminate()</code>。</li>
</ul>
</li>
</ul>
<h3 id="4-链接-ABI-OS-交互相关：extern-C-、属性、导出修饰符"><a href="#4-链接-ABI-OS-交互相关：extern-C-、属性、导出修饰符" class="headerlink" title="4. 链接 &#x2F; ABI &#x2F; OS 交互相关：extern &quot;C&quot;、属性、导出修饰符"></a>4. 链接 &#x2F; ABI &#x2F; OS 交互相关：<code>extern &quot;C&quot;</code>、属性、导出修饰符</h3><p>这些是 C++ 中**真正接近“控制操作系统”**的一类修饰符。</p>
<ul>
<li><code>extern &quot;C&quot;</code>：<ul>
<li>告诉编译器对这些函数采用 C ABI（不使用 C++ 名字改编、调用约定相容 C），以便跟 C 代码或 OS 提供的 C 接口链接。</li>
</ul>
</li>
<li>平台相关修饰符（非标准，但在工程中非常多）：<ul>
<li>Windows: <code>__declspec(dllexport)</code>, <code>__declspec(dllimport)</code><ul>
<li>控制符号是否导出到 DLL &#x2F; 从 DLL 导入，OS loader 才能找到这些函数。</li>
</ul>
</li>
<li>GCC&#x2F;Clang: <code>__attribute__((visibility(&quot;default&quot;)))</code> 等<ul>
<li>控制 ELF 符号的可见性。</li>
</ul>
</li>
</ul>
</li>
<li>设计原理：<ul>
<li>C++ 想要保持“几乎可以直接与 C 和 OS 接口”的能力，所以必须提供<strong>控制符号导出&#x2F;调用约定&#x2F;可见性</strong>的语言或扩展机制。</li>
</ul>
</li>
</ul>
<h3 id="5-对齐与属性：alignas、-nodiscard-等"><a href="#5-对齐与属性：alignas、-nodiscard-等" class="headerlink" title="5. 对齐与属性：alignas、[[nodiscard]] 等"></a>5. 对齐与属性：<code>alignas</code>、<code>[[nodiscard]]</code> 等</h3><ul>
<li><code>alignas(N)</code>：指定对象的对齐要求（比如 SIMD 需要 16&#x2F;32 字节对齐），编译器在分配内存时满足这个要求，间接影响性能和硬件指令使用。</li>
<li><code>[[nodiscard]]</code>, <code>[[noreturn]]</code>: 多数是“编译器提示&#x2F;警告控制”，不直接涉及内存或 OS。</li>
</ul>
<hr>
<h2 id="四、到底哪些“控制内存”、哪些“控制编译器”、哪些“控制-OS”？"><a href="#四、到底哪些“控制内存”、哪些“控制编译器”、哪些“控制-OS”？" class="headerlink" title="四、到底哪些“控制内存”、哪些“控制编译器”、哪些“控制 OS”？"></a>四、到底哪些“控制内存”、哪些“控制编译器”、哪些“控制 OS”？</h2><p>粗暴归类一下（<em>只列主要代表，非完全列表</em>）：</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul>
<li><strong>偏“内存&#x2F;并发”的：</strong><ul>
<li><code>static</code>（类级共享存储、生命周期）</li>
<li><code>final</code>（字段&#x2F;变量的不变性 + JMM 里的可见性）</li>
<li><code>volatile</code>（可见性 + 禁止重排）</li>
<li><code>synchronized</code>（锁 &amp; happens-before，JVM 内部用锁结构，有时会用到 OS 原语）</li>
<li><code>transient</code>（影响对象持久化的“内存视图”）</li>
</ul>
</li>
<li><strong>偏“编译器&#x2F;类型系统”的：</strong><ul>
<li><code>public/protected/private</code>（访问控制）</li>
<li><code>abstract</code>（抽象类&#x2F;方法）</li>
<li><code>final</code>（对类&#x2F;方法不可继承&#x2F;不可覆写）</li>
<li><code>strictfp</code>（浮点语义约束）</li>
</ul>
</li>
<li><strong>偏“OS &#x2F; 互操作”的：</strong><ul>
<li><code>native</code>：告诉 JVM 要到本地库里找实现，经过 JNI -&gt; OS 动态库接口。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul>
<li><strong>偏“内存&#x2F;生命周期&#x2F;布局”的：</strong><ul>
<li><code>static</code>（静态存储期 + 内部链接&#x2F;局部静态）</li>
<li><code>thread_local</code>（TLS：每线程一份状态）</li>
<li><code>const</code> &#x2F; <code>mutable</code>（可变性约束）</li>
<li><code>volatile</code>（内存映射 IO &#x2F; 特殊内存位置）</li>
<li><code>alignas</code>（对齐）</li>
</ul>
</li>
<li><strong>偏“并发&#x2F;异常语义”的：</strong><ul>
<li><code>noexcept</code>（异常传播语义）</li>
<li><code>volatile</code>（很少用于并发，但仍会影响编译器的重排）</li>
</ul>
</li>
<li><strong>偏“编译器静态行为&#x2F;优化”的：</strong><ul>
<li><code>inline</code>, <code>register</code>（优化提示 &amp; ODR 语义）</li>
<li><code>constexpr</code> &#x2F; <code>consteval</code>（编译期求值）</li>
<li><code>explicit</code>, <code>virtual</code>, <code>override</code>, <code>final</code>（OOP 语义 &#x2F; 编译期检查）</li>
<li><code>[[nodiscard]]</code>, <code>[[likely]]</code> 等属性（警告&#x2F;预测）</li>
</ul>
</li>
<li><strong>偏“OS &#x2F; ABI &#x2F; 互操作”的：</strong><ul>
<li><code>extern</code>, <code>static</code>（全局作用域下的链接属性）</li>
<li><code>extern &quot;C&quot;</code>（选择 C ABI，与 OS &#x2F; C 库互动）</li>
<li><code>__declspec(dllexport/dllimport)</code>, <code>__attribute__((visibility))</code> 等（控制动态库导出、符号可见性）</li>
<li>这些最终决定的是 <strong>目标文件中的符号表、段信息、调用约定</strong>，由 OS loader 和链接器使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="五、设计原理上的几个大方向"><a href="#五、设计原理上的几个大方向" class="headerlink" title="五、设计原理上的几个大方向"></a>五、设计原理上的几个大方向</h2><ol>
<li><strong>把“程序员意图”写进类型系统和声明</strong><ul>
<li>比如：“这个值不会改”（<code>final</code>, <code>const</code>）、“这个函数不会抛异常”（<code>noexcept</code>）、“这个类不允许继承”（<code>final</code>）、“这只是 C 接口，不要 C++ name mangling”（<code>extern &quot;C&quot;</code>）。</li>
<li>好处：编译器能检查、优化；读代码的人也更好理解。</li>
</ul>
</li>
<li><strong>把“内存与并发的危险细节”封装在少数受控的修饰符中</strong><ul>
<li><code>volatile</code>, <code>synchronized</code>, <code>thread_local</code>, <code>alignas</code> 等。</li>
<li>语言层面给出一套抽象，编译器负责映射到底层 CPU &#x2F; OS 原语。</li>
</ul>
</li>
<li><strong>支持大规模工程和模块化</strong><ul>
<li>访问控制（<code>public/private</code>）、链接属性（<code>extern/static</code>）、动态库导出（<code>dllexport</code> 等），都是为了解决“多文件、多模块、多团队协作”的问题。</li>
</ul>
</li>
<li><strong>保持与 OS &#x2F; 其它语言的互操作</strong><ul>
<li>C++ 通过 <code>extern &quot;C&quot;</code> 和各种属性，Java 通过 <code>native</code> + JNI。</li>
<li>设计思路是：<strong>语言层面描述 ABI 和边界，编译器&#x2F;运行时完成与 OS 的桥接</strong>。</li>
</ul>
</li>
<li><strong>给优化留空间</strong><ul>
<li>很多修饰符的语义都是 <strong>“比默认情况更强的约束”</strong>，约束越强，优化空间越大：<ul>
<li>不能被改（<code>final</code>, <code>const</code>） -&gt; 常量折叠、内联</li>
<li>不会被 override（<code>final</code> 方法） -&gt; 去虚函数表、直接调用</li>
<li>不会抛异常（<code>noexcept</code>） -&gt; 精简异常处理数据结构</li>
<li>编译期可算（<code>constexpr</code>） -&gt; 运行时开销为 0</li>
</ul>
</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Zed</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/">http://example.com/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-cpp/">java cpp</a></div><div class="post-share"><div class="social-share" data-image="/img/asuka.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/21/Session-and-Cookie/" title="Session and Cookie"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Session and Cookie</div></div><div class="info-2"><div class="info-item-1">HTTP 协议本身是无状态的。这意味着每一次客户端（浏览器）向服务器发出的请求都是独立的，服务器不会自动记住上一次请求是谁发来的。为了创建连续、个性化的用户体验（比如保持用户登录状态），就需要 Session 和 Cookie 来帮助服务器“记住”客户端。  一、Cookie1. 是什么？Cookie 是一小段文本信息（通常最大为 4KB），由服务器通过 HTTP 响应的 Set-Cookie 头部发送给客户端（浏览器）。浏览器会将这些信息存储起来，并在后续对同一域名的请求中，通过 HTTP 请求的 Cookie 头部自动将其回传给服务器。 你可以把 Cookie 想象成服务器给浏览器的一张“会员卡”，上面记录了一些基本信息（如会员ID、偏好设置），浏览器每次访问这家“店”（服务器）时都会出示这张卡。 2. 工作原理 首次请求：用户首次访问网站，浏览器发送请求，请求中没有 Cookie。 服务器响应：服务器需要记录状态（比如用户选择了语言偏好），于是在响应头中加入 Set-Cookie: key=value。 浏览器存储：浏览器收到响应后，会将这个 Cookie...</div></div></div></a><a class="pagination-related" href="/2025/11/23/docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="docker使用与开发"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">docker使用与开发</div></div><div class="info-2"><div class="info-item-1">Docker 开发入门与实践指南 目标：帮你从开发者视角理解 Docker，并学会用 Docker 搭建 &amp; 驱动日常开发环境。   1. Docker 是什么？用一句话概括：  Docker &#x3D; 用镜像和容器来管理“运行环境”的工具，让程序在任何机器上都以同样的方式运行。  传统开发&#x2F;部署方式的问题：  开发机装各种依赖：JDK &#x2F; Python &#x2F; MySQL &#x2F; Redis &#x2F; Kafka… 服务器上还要重复装一遍，而且版本必须对得上 “我这跑得好好的，服务器怎么就挂了？”——典型的环境不一致问题  Docker 的思路：  把「程序 + 依赖 + 配置 + 启动命令」打包到一个 镜像 (Image) 里   运行镜像的时候，启动一个 容器 (Container)   容器之间、容器与宿主机之间是相对隔离的   任何装了 Docker 的机器上，只要有这个镜像，就能得到一致的运行环境   2. Docker 核心概念2.1 Image（镜像） 类似 “系统快照 +...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/asuka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zed</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ze-d"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">welcome to my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8E%E6%95%B4%E4%BD%93%E4%B8%8A%E7%9C%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E5%87%A0%E4%B8%AA%E7%BB%B4%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">一、从整体上看修饰符：几个维度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E8%B0%81%E7%AE%A1%E5%86%85%E5%AD%98%EF%BC%9F%E8%B0%81%E7%AE%A1%E5%B9%B6%E5%8F%91%EF%BC%9F%E8%B0%81%E7%AE%A1-OS%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">二、Java 中的修饰符：谁管内存？谁管并发？谁管 OS？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Apublic-protected-private-%E5%8C%85%E5%8F%AF%E8%A7%81"><span class="toc-number">2.1.</span> <span class="toc-text">1. 访问控制修饰符：public &#x2F; protected &#x2F; private &#x2F; 包可见</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-static%EF%BC%9A%E7%B1%BB%E7%BA%A7%E5%88%AB%E6%88%90%E5%91%98-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">2. static：类级别成员 &#x2F; 静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-final%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%80%A7%E8%B5%8B%E5%80%BC-%E4%B8%8D%E5%8F%AF%E7%BB%A7%E6%89%BF-%E4%B8%8D%E5%8F%AF%E8%A6%86%E7%9B%96"><span class="toc-number">2.3.</span> <span class="toc-text">3. final：一次性赋值 &#x2F; 不可继承 &#x2F; 不可覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-volatile%EF%BC%9A%E5%8F%AF%E8%A7%81%E6%80%A7-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92"><span class="toc-number">2.4.</span> <span class="toc-text">4. volatile：可见性 + 禁止重排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-synchronized%EF%BC%9A%E4%BA%92%E6%96%A5%E9%94%81-happens-before"><span class="toc-number">2.5.</span> <span class="toc-text">5. synchronized：互斥锁 + happens-before</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-transient%EF%BC%9A%E5%BD%B1%E5%93%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E2%80%9C%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE%E2%80%9D%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">6. transient：影响序列化（对象持久化的“内存视图”）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-abstract-native-strictfp-%E7%AD%89"><span class="toc-number">2.7.</span> <span class="toc-text">7. abstract &#x2F; native &#x2F; strictfp 等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C-%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E6%9B%B4%E8%B4%B4%E8%BF%91%E7%A1%AC%E4%BB%B6-OS"><span class="toc-number">3.</span> <span class="toc-text">三、C++ 中的修饰符：更贴近硬件 &amp; OS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%B1%BB%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Astatic-extern-thread-local-%EF%BC%88%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84-register%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. 存储类修饰符：static, extern, thread_local, （历史上的 register）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%EF%BC%88%E5%9C%A8-C-C-%E9%87%8C%E5%90%AB%E4%B9%89%E6%AF%94-Java-%E5%A4%9A%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">static（在 C&#x2F;C++ 里含义比 Java 多）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern"><span class="toc-number">3.1.2.</span> <span class="toc-text">extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-local"><span class="toc-number">3.1.3.</span> <span class="toc-text">thread_local</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#register%EF%BC%88%E5%8E%86%E5%8F%B2%E9%81%97%E8%BF%B9%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">register（历史遗迹）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9Aconst-volatile-mutable"><span class="toc-number">3.2.</span> <span class="toc-text">2. 类型限定符：const, volatile, mutable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">3.2.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-number">3.2.2.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable"><span class="toc-number">3.2.3.</span> <span class="toc-text">mutable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0-%E7%B1%BB%E7%9B%B8%E5%85%B3%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9Ainline-virtual-explicit-constexpr-override-final-noexcept%E2%80%A6"><span class="toc-number">3.3.</span> <span class="toc-text">3. 函数&#x2F;类相关修饰符：inline, virtual, explicit, constexpr, override, final, noexcept…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E6%8E%A5-ABI-OS-%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%EF%BC%9Aextern-C-%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E5%AF%BC%E5%87%BA%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">4. 链接 &#x2F; ABI &#x2F; OS 交互相关：extern &quot;C&quot;、属性、导出修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E9%BD%90%E4%B8%8E%E5%B1%9E%E6%80%A7%EF%BC%9Aalignas%E3%80%81-nodiscard-%E7%AD%89"><span class="toc-number">3.5.</span> <span class="toc-text">5. 对齐与属性：alignas、[[nodiscard]] 等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%88%B0%E5%BA%95%E5%93%AA%E4%BA%9B%E2%80%9C%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E2%80%9D%E3%80%81%E5%93%AA%E4%BA%9B%E2%80%9C%E6%8E%A7%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8%E2%80%9D%E3%80%81%E5%93%AA%E4%BA%9B%E2%80%9C%E6%8E%A7%E5%88%B6-OS%E2%80%9D%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">四、到底哪些“控制内存”、哪些“控制编译器”、哪些“控制 OS”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java"><span class="toc-number">4.1.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C"><span class="toc-number">4.2.</span> <span class="toc-text">C++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A4%A7%E6%96%B9%E5%90%91"><span class="toc-number">5.</span> <span class="toc-text">五、设计原理上的几个大方向</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/23/Gradle%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Gradle使用指南">Gradle使用指南</a><time datetime="2025-11-23T08:07:19.000Z" title="Created 2025-11-23 16:07:19">2025-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/23/docker%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="docker使用与开发">docker使用与开发</a><time datetime="2025-11-23T08:07:06.000Z" title="Created 2025-11-23 16:07:06">2025-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/19/%E4%BF%AE%E9%A5%B0%E7%AC%A6/" title="修饰符">修饰符</a><time datetime="2025-11-19T11:53:53.000Z" title="Created 2025-11-19 19:53:53">2025-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/21/Session-and-Cookie/" title="Session and Cookie">Session and Cookie</a><time datetime="2025-08-21T02:43:34.000Z" title="Created 2025-08-21 10:43:34">2025-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/21/%E7%90%86%E8%A7%A3OAuth-2-0/" title="理解OAuth 2.0">理解OAuth 2.0</a><time datetime="2025-08-21T02:18:48.000Z" title="Created 2025-08-21 10:18:48">2025-08-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/bkground.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Zed</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>